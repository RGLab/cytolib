// Copyright 2019 Fred Hutchinson Cancer Research Center
// See the included LICENSE file for details on the licence that is granted to the user of this software.
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GatingSet.proto

#include <cytolib/GatingSet.pb.h>
#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BOOL_GATE_OP_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_COMP_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CytoFrame_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PARAM_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_POPINDICES_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_POPSTATS_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_biexpTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_calibrationTable_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_clusterGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_coordinate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_fasinhTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_flinTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_logGML2Trans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_logTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_logicleTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_paramRange_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_quadGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_scaleTrans_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TRANS_TBL_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_boolGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ellipseGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_paramPoly_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_populationTree_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_rangeGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_trans_local_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_trans_pair_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_treeNodes_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_polygonGate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_nodeProperties_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<5> scc_info_gate_GatingSet_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_GatingSet_2eproto ::google::protobuf::internal::SCCInfo<8> scc_info_transformation_GatingSet_2eproto;
namespace pb {
class paramRangeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<paramRange> _instance;
} _paramRange_default_instance_;
class rangeGateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<rangeGate> _instance;
} _rangeGate_default_instance_;
class paramPolyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<paramPoly> _instance;
} _paramPoly_default_instance_;
class polygonGateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<polygonGate> _instance;
} _polygonGate_default_instance_;
class coordinateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<coordinate> _instance;
} _coordinate_default_instance_;
class ellipseGateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ellipseGate> _instance;
} _ellipseGate_default_instance_;
class BOOL_GATE_OPDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BOOL_GATE_OP> _instance;
} _BOOL_GATE_OP_default_instance_;
class boolGateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<boolGate> _instance;
} _boolGate_default_instance_;
class clusterGateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<clusterGate> _instance;
} _clusterGate_default_instance_;
class quadGateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<quadGate> _instance;
} _quadGate_default_instance_;
class gateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<gate> _instance;
} _gate_default_instance_;
class POPSTATSDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<POPSTATS> _instance;
} _POPSTATS_default_instance_;
class calibrationTableDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<calibrationTable> _instance;
} _calibrationTable_default_instance_;
class biexpTransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<biexpTrans> _instance;
} _biexpTrans_default_instance_;
class fasinhTransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<fasinhTrans> _instance;
} _fasinhTrans_default_instance_;
class scaleTransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<scaleTrans> _instance;
} _scaleTrans_default_instance_;
class flinTransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<flinTrans> _instance;
} _flinTrans_default_instance_;
class logTransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<logTrans> _instance;
} _logTrans_default_instance_;
class logGML2TransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<logGML2Trans> _instance;
} _logGML2Trans_default_instance_;
class logicleTransDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<logicleTrans> _instance;
} _logicleTrans_default_instance_;
class transformationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<transformation> _instance;
} _transformation_default_instance_;
class trans_pairDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<trans_pair> _instance;
} _trans_pair_default_instance_;
class trans_localDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<trans_local> _instance;
} _trans_local_default_instance_;
class POPINDICESDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<POPINDICES> _instance;
} _POPINDICES_default_instance_;
class nodePropertiesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<nodeProperties> _instance;
} _nodeProperties_default_instance_;
class treeNodesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<treeNodes> _instance;
} _treeNodes_default_instance_;
class populationTreeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<populationTree> _instance;
} _populationTree_default_instance_;
class COMPDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<COMP> _instance;
} _COMP_default_instance_;
class PARAMDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PARAM> _instance;
} _PARAM_default_instance_;
class GatingHierarchyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GatingHierarchy> _instance;
} _GatingHierarchy_default_instance_;
class CytoFrameDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CytoFrame> _instance;
} _CytoFrame_default_instance_;
class TRANS_TBLDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TRANS_TBL> _instance;
} _TRANS_TBL_default_instance_;
class GatingSetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GatingSet> _instance;
} _GatingSet_default_instance_;
}  // namespace pb
static void InitDefaultsparamRange_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_paramRange_default_instance_;
    new (ptr) ::pb::paramRange();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::paramRange::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_paramRange_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsparamRange_GatingSet_2eproto}, {}};

static void InitDefaultsrangeGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_rangeGate_default_instance_;
    new (ptr) ::pb::rangeGate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::rangeGate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_rangeGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsrangeGate_GatingSet_2eproto}, {
      &scc_info_paramRange_GatingSet_2eproto.base,}};

static void InitDefaultsparamPoly_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_paramPoly_default_instance_;
    new (ptr) ::pb::paramPoly();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::paramPoly::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_paramPoly_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsparamPoly_GatingSet_2eproto}, {
      &scc_info_coordinate_GatingSet_2eproto.base,}};

static void InitDefaultspolygonGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_polygonGate_default_instance_;
    new (ptr) ::pb::polygonGate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::polygonGate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_polygonGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultspolygonGate_GatingSet_2eproto}, {
      &scc_info_paramPoly_GatingSet_2eproto.base,
      &scc_info_quadGate_GatingSet_2eproto.base,}};

static void InitDefaultscoordinate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_coordinate_default_instance_;
    new (ptr) ::pb::coordinate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::coordinate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_coordinate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultscoordinate_GatingSet_2eproto}, {}};

static void InitDefaultsellipseGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_ellipseGate_default_instance_;
    new (ptr) ::pb::ellipseGate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::ellipseGate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ellipseGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsellipseGate_GatingSet_2eproto}, {
      &scc_info_coordinate_GatingSet_2eproto.base,}};

static void InitDefaultsBOOL_GATE_OP_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_BOOL_GATE_OP_default_instance_;
    new (ptr) ::pb::BOOL_GATE_OP();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::BOOL_GATE_OP::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BOOL_GATE_OP_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBOOL_GATE_OP_GatingSet_2eproto}, {}};

static void InitDefaultsboolGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_boolGate_default_instance_;
    new (ptr) ::pb::boolGate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::boolGate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_boolGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsboolGate_GatingSet_2eproto}, {
      &scc_info_BOOL_GATE_OP_GatingSet_2eproto.base,}};

static void InitDefaultsclusterGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_clusterGate_default_instance_;
    new (ptr) ::pb::clusterGate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::clusterGate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_clusterGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsclusterGate_GatingSet_2eproto}, {}};

static void InitDefaultsquadGate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_quadGate_default_instance_;
    new (ptr) ::pb::quadGate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::quadGate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_quadGate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsquadGate_GatingSet_2eproto}, {}};

static void InitDefaultsgate_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_gate_default_instance_;
    new (ptr) ::pb::gate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::gate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<5> scc_info_gate_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 5, InitDefaultsgate_GatingSet_2eproto}, {
      &scc_info_rangeGate_GatingSet_2eproto.base,
      &scc_info_polygonGate_GatingSet_2eproto.base,
      &scc_info_ellipseGate_GatingSet_2eproto.base,
      &scc_info_boolGate_GatingSet_2eproto.base,
      &scc_info_clusterGate_GatingSet_2eproto.base,}};

static void InitDefaultsPOPSTATS_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_POPSTATS_default_instance_;
    new (ptr) ::pb::POPSTATS();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::POPSTATS::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_POPSTATS_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPOPSTATS_GatingSet_2eproto}, {}};

static void InitDefaultscalibrationTable_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_calibrationTable_default_instance_;
    new (ptr) ::pb::calibrationTable();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::calibrationTable::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_calibrationTable_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultscalibrationTable_GatingSet_2eproto}, {}};

static void InitDefaultsbiexpTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_biexpTrans_default_instance_;
    new (ptr) ::pb::biexpTrans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::biexpTrans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_biexpTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsbiexpTrans_GatingSet_2eproto}, {}};

static void InitDefaultsfasinhTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_fasinhTrans_default_instance_;
    new (ptr) ::pb::fasinhTrans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::fasinhTrans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_fasinhTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsfasinhTrans_GatingSet_2eproto}, {}};

static void InitDefaultsscaleTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_scaleTrans_default_instance_;
    new (ptr) ::pb::scaleTrans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::scaleTrans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_scaleTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscaleTrans_GatingSet_2eproto}, {}};

static void InitDefaultsflinTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_flinTrans_default_instance_;
    new (ptr) ::pb::flinTrans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::flinTrans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_flinTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsflinTrans_GatingSet_2eproto}, {}};

static void InitDefaultslogTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_logTrans_default_instance_;
    new (ptr) ::pb::logTrans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::logTrans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_logTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultslogTrans_GatingSet_2eproto}, {}};

static void InitDefaultslogGML2Trans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_logGML2Trans_default_instance_;
    new (ptr) ::pb::logGML2Trans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::logGML2Trans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_logGML2Trans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultslogGML2Trans_GatingSet_2eproto}, {}};

static void InitDefaultslogicleTrans_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_logicleTrans_default_instance_;
    new (ptr) ::pb::logicleTrans();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::logicleTrans::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_logicleTrans_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultslogicleTrans_GatingSet_2eproto}, {}};

static void InitDefaultstransformation_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_transformation_default_instance_;
    new (ptr) ::pb::transformation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::transformation::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<8> scc_info_transformation_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 8, InitDefaultstransformation_GatingSet_2eproto}, {
      &scc_info_calibrationTable_GatingSet_2eproto.base,
      &scc_info_biexpTrans_GatingSet_2eproto.base,
      &scc_info_logTrans_GatingSet_2eproto.base,
      &scc_info_flinTrans_GatingSet_2eproto.base,
      &scc_info_scaleTrans_GatingSet_2eproto.base,
      &scc_info_fasinhTrans_GatingSet_2eproto.base,
      &scc_info_logicleTrans_GatingSet_2eproto.base,
      &scc_info_logGML2Trans_GatingSet_2eproto.base,}};

static void InitDefaultstrans_pair_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_trans_pair_default_instance_;
    new (ptr) ::pb::trans_pair();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::trans_pair::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_trans_pair_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultstrans_pair_GatingSet_2eproto}, {
      &scc_info_transformation_GatingSet_2eproto.base,}};

static void InitDefaultstrans_local_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_trans_local_default_instance_;
    new (ptr) ::pb::trans_local();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::trans_local::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_trans_local_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultstrans_local_GatingSet_2eproto}, {
      &scc_info_trans_pair_GatingSet_2eproto.base,}};

static void InitDefaultsPOPINDICES_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_POPINDICES_default_instance_;
    new (ptr) ::pb::POPINDICES();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::POPINDICES::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_POPINDICES_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPOPINDICES_GatingSet_2eproto}, {}};

static void InitDefaultsnodeProperties_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_nodeProperties_default_instance_;
    new (ptr) ::pb::nodeProperties();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::nodeProperties::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_nodeProperties_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsnodeProperties_GatingSet_2eproto}, {
      &scc_info_POPSTATS_GatingSet_2eproto.base,
      &scc_info_POPINDICES_GatingSet_2eproto.base,
      &scc_info_gate_GatingSet_2eproto.base,}};

static void InitDefaultstreeNodes_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_treeNodes_default_instance_;
    new (ptr) ::pb::treeNodes();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::treeNodes::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_treeNodes_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultstreeNodes_GatingSet_2eproto}, {
      &scc_info_nodeProperties_GatingSet_2eproto.base,}};

static void InitDefaultspopulationTree_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_populationTree_default_instance_;
    new (ptr) ::pb::populationTree();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::populationTree::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_populationTree_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultspopulationTree_GatingSet_2eproto}, {
      &scc_info_treeNodes_GatingSet_2eproto.base,}};

static void InitDefaultsCOMP_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_COMP_default_instance_;
    new (ptr) ::pb::COMP();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::COMP::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_COMP_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCOMP_GatingSet_2eproto}, {}};

static void InitDefaultsPARAM_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_PARAM_default_instance_;
    new (ptr) ::pb::PARAM();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::PARAM::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_PARAM_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPARAM_GatingSet_2eproto}, {}};

static void InitDefaultsGatingHierarchy_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_GatingHierarchy_default_instance_;
    new (ptr) ::pb::GatingHierarchy();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::GatingHierarchy::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<5> scc_info_GatingHierarchy_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 5, InitDefaultsGatingHierarchy_GatingSet_2eproto}, {
      &scc_info_populationTree_GatingSet_2eproto.base,
      &scc_info_COMP_GatingSet_2eproto.base,
      &scc_info_PARAM_GatingSet_2eproto.base,
      &scc_info_trans_local_GatingSet_2eproto.base,
      &scc_info_CytoFrame_GatingSet_2eproto.base,}};

static void InitDefaultsCytoFrame_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_CytoFrame_default_instance_;
    new (ptr) ::pb::CytoFrame();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::CytoFrame::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CytoFrame_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCytoFrame_GatingSet_2eproto}, {}};

static void InitDefaultsTRANS_TBL_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_TRANS_TBL_default_instance_;
    new (ptr) ::pb::TRANS_TBL();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::TRANS_TBL::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TRANS_TBL_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTRANS_TBL_GatingSet_2eproto}, {
      &scc_info_transformation_GatingSet_2eproto.base,}};

static void InitDefaultsGatingSet_GatingSet_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pb::_GatingSet_default_instance_;
    new (ptr) ::pb::GatingSet();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pb::GatingSet::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_GatingSet_GatingSet_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsGatingSet_GatingSet_2eproto}, {
      &scc_info_TRANS_TBL_GatingSet_2eproto.base,
      &scc_info_trans_local_GatingSet_2eproto.base,}};

namespace pb {
bool QUAD_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool GATE_TYPE_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

bool ind_type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool TRANS_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void paramRange::InitAsDefaultInstance() {
}
class paramRange::HasBitSetters {
 public:
  static void set_has_name(paramRange* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_min(paramRange* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_max(paramRange* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int paramRange::kNameFieldNumber;
const int paramRange::kMinFieldNumber;
const int paramRange::kMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

paramRange::paramRange()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.paramRange)
}
paramRange::paramRange(const paramRange& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&min_, &from.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&min_)) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:pb.paramRange)
}

void paramRange::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_paramRange_GatingSet_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
}

paramRange::~paramRange() {
  // @@protoc_insertion_point(destructor:pb.paramRange)
  SharedDtor();
}

void paramRange::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void paramRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const paramRange& paramRange::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_paramRange_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void paramRange::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.paramRange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_) -
        reinterpret_cast<char*>(&min_)) + sizeof(max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* paramRange::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<paramRange*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // required float min = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_min(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // required float max = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_max(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool paramRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.paramRange)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float min = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_min(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float max = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_max(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.paramRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.paramRange)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void paramRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.paramRange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required float min = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->min(), output);
  }

  // required float max = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->max(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.paramRange)
}

size_t paramRange::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.paramRange)
  size_t total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_min()) {
    // required float min = 2;
    total_size += 1 + 4;
  }

  if (has_max()) {
    // required float max = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t paramRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.paramRange)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required float min = 2;
    total_size += 1 + 4;

    // required float max = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void paramRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const paramRange*>(&from));
}

void paramRange::MergeFrom(const paramRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.paramRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      min_ = from.min_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_ = from.max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void paramRange::CopyFrom(const paramRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.paramRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool paramRange::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void paramRange::Swap(paramRange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void paramRange::InternalSwap(paramRange* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(min_, other->min_);
  swap(max_, other->max_);
}

::std::string paramRange::GetTypeName() const {
  return "pb.paramRange";
}


// ===================================================================

void rangeGate::InitAsDefaultInstance() {
  ::pb::_rangeGate_default_instance_._instance.get_mutable()->param_ = const_cast< ::pb::paramRange*>(
      ::pb::paramRange::internal_default_instance());
}
class rangeGate::HasBitSetters {
 public:
  static const ::pb::paramRange& param(const rangeGate* msg);
  static void set_has_param(rangeGate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::pb::paramRange&
rangeGate::HasBitSetters::param(const rangeGate* msg) {
  return *msg->param_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int rangeGate::kParamFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

rangeGate::rangeGate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.rangeGate)
}
rangeGate::rangeGate(const rangeGate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_param()) {
    param_ = new ::pb::paramRange(*from.param_);
  } else {
    param_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pb.rangeGate)
}

void rangeGate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_rangeGate_GatingSet_2eproto.base);
  param_ = nullptr;
}

rangeGate::~rangeGate() {
  // @@protoc_insertion_point(destructor:pb.rangeGate)
  SharedDtor();
}

void rangeGate::SharedDtor() {
  if (this != internal_default_instance()) delete param_;
}

void rangeGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const rangeGate& rangeGate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_rangeGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void rangeGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.rangeGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(param_ != nullptr);
    param_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* rangeGate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<rangeGate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .pb.paramRange param = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::paramRange::_InternalParse;
        object = msg->mutable_param();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool rangeGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.rangeGate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .pb.paramRange param = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_param()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.rangeGate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.rangeGate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void rangeGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.rangeGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.paramRange param = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, HasBitSetters::param(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.rangeGate)
}

size_t rangeGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.rangeGate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .pb.paramRange param = 1;
  if (has_param()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *param_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void rangeGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const rangeGate*>(&from));
}

void rangeGate::MergeFrom(const rangeGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.rangeGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_param()) {
    mutable_param()->::pb::paramRange::MergeFrom(from.param());
  }
}

void rangeGate::CopyFrom(const rangeGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.rangeGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rangeGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_param()) {
    if (!this->param_->IsInitialized()) return false;
  }
  return true;
}

void rangeGate::Swap(rangeGate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void rangeGate::InternalSwap(rangeGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(param_, other->param_);
}

::std::string rangeGate::GetTypeName() const {
  return "pb.rangeGate";
}


// ===================================================================

void paramPoly::InitAsDefaultInstance() {
}
class paramPoly::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int paramPoly::kParamsFieldNumber;
const int paramPoly::kVerticesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

paramPoly::paramPoly()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.paramPoly)
}
paramPoly::paramPoly(const paramPoly& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      params_(from.params_),
      vertices_(from.vertices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.paramPoly)
}

void paramPoly::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_paramPoly_GatingSet_2eproto.base);
}

paramPoly::~paramPoly() {
  // @@protoc_insertion_point(destructor:pb.paramPoly)
  SharedDtor();
}

void paramPoly::SharedDtor() {
}

void paramPoly::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const paramPoly& paramPoly::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_paramPoly_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void paramPoly::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.paramPoly)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  params_.Clear();
  vertices_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* paramPoly::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<paramPoly*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated string params = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_params();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // repeated .pb.coordinate vertices = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::coordinate::_InternalParse;
          object = msg->add_vertices();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool paramPoly::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.paramPoly)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string params = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_params()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.coordinate vertices = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_vertices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.paramPoly)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.paramPoly)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void paramPoly::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.paramPoly)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string params = 1;
  for (int i = 0, n = this->params_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->params(i), output);
  }

  // repeated .pb.coordinate vertices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vertices_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2,
      this->vertices(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.paramPoly)
}

size_t paramPoly::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.paramPoly)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string params = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->params_size());
  for (int i = 0, n = this->params_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->params(i));
  }

  // repeated .pb.coordinate vertices = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->vertices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->vertices(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void paramPoly::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const paramPoly*>(&from));
}

void paramPoly::MergeFrom(const paramPoly& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.paramPoly)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  params_.MergeFrom(from.params_);
  vertices_.MergeFrom(from.vertices_);
}

void paramPoly::CopyFrom(const paramPoly& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.paramPoly)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool paramPoly::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->vertices())) return false;
  return true;
}

void paramPoly::Swap(paramPoly* other) {
  if (other == this) return;
  InternalSwap(other);
}
void paramPoly::InternalSwap(paramPoly* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  params_.InternalSwap(CastToBase(&other->params_));
  CastToBase(&vertices_)->InternalSwap(CastToBase(&other->vertices_));
}

::std::string paramPoly::GetTypeName() const {
  return "pb.paramPoly";
}


// ===================================================================

void polygonGate::InitAsDefaultInstance() {
  ::pb::_polygonGate_default_instance_._instance.get_mutable()->param_ = const_cast< ::pb::paramPoly*>(
      ::pb::paramPoly::internal_default_instance());
  ::pb::_polygonGate_default_instance_._instance.get_mutable()->qg_ = const_cast< ::pb::quadGate*>(
      ::pb::quadGate::internal_default_instance());
}
class polygonGate::HasBitSetters {
 public:
  static const ::pb::paramPoly& param(const polygonGate* msg);
  static void set_has_param(polygonGate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::pb::quadGate& qg(const polygonGate* msg);
  static void set_has_qg(polygonGate* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::pb::paramPoly&
polygonGate::HasBitSetters::param(const polygonGate* msg) {
  return *msg->param_;
}
const ::pb::quadGate&
polygonGate::HasBitSetters::qg(const polygonGate* msg) {
  return *msg->qg_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int polygonGate::kParamFieldNumber;
const int polygonGate::kQgFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

polygonGate::polygonGate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.polygonGate)
}
polygonGate::polygonGate(const polygonGate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_param()) {
    param_ = new ::pb::paramPoly(*from.param_);
  } else {
    param_ = nullptr;
  }
  if (from.has_qg()) {
    qg_ = new ::pb::quadGate(*from.qg_);
  } else {
    qg_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pb.polygonGate)
}

void polygonGate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_polygonGate_GatingSet_2eproto.base);
  ::memset(&param_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&qg_) -
      reinterpret_cast<char*>(&param_)) + sizeof(qg_));
}

polygonGate::~polygonGate() {
  // @@protoc_insertion_point(destructor:pb.polygonGate)
  SharedDtor();
}

void polygonGate::SharedDtor() {
  if (this != internal_default_instance()) delete param_;
  if (this != internal_default_instance()) delete qg_;
}

void polygonGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const polygonGate& polygonGate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_polygonGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void polygonGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.polygonGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(param_ != nullptr);
      param_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(qg_ != nullptr);
      qg_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* polygonGate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<polygonGate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .pb.paramPoly param = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::paramPoly::_InternalParse;
        object = msg->mutable_param();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.quadGate qg = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::quadGate::_InternalParse;
        object = msg->mutable_qg();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool polygonGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.polygonGate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .pb.paramPoly param = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_param()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.quadGate qg = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_qg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.polygonGate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.polygonGate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void polygonGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.polygonGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.paramPoly param = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, HasBitSetters::param(this), output);
  }

  // optional .pb.quadGate qg = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, HasBitSetters::qg(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.polygonGate)
}

size_t polygonGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.polygonGate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .pb.paramPoly param = 1;
  if (has_param()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *param_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pb.quadGate qg = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *qg_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void polygonGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const polygonGate*>(&from));
}

void polygonGate::MergeFrom(const polygonGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.polygonGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_param()->::pb::paramPoly::MergeFrom(from.param());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_qg()->::pb::quadGate::MergeFrom(from.qg());
    }
  }
}

void polygonGate::CopyFrom(const polygonGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.polygonGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool polygonGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_param()) {
    if (!this->param_->IsInitialized()) return false;
  }
  if (has_qg()) {
    if (!this->qg_->IsInitialized()) return false;
  }
  return true;
}

void polygonGate::Swap(polygonGate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void polygonGate::InternalSwap(polygonGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(param_, other->param_);
  swap(qg_, other->qg_);
}

::std::string polygonGate::GetTypeName() const {
  return "pb.polygonGate";
}


// ===================================================================

void coordinate::InitAsDefaultInstance() {
}
class coordinate::HasBitSetters {
 public:
  static void set_has_x(coordinate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(coordinate* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int coordinate::kXFieldNumber;
const int coordinate::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

coordinate::coordinate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.coordinate)
}
coordinate::coordinate(const coordinate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:pb.coordinate)
}

void coordinate::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

coordinate::~coordinate() {
  // @@protoc_insertion_point(destructor:pb.coordinate)
  SharedDtor();
}

void coordinate::SharedDtor() {
}

void coordinate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const coordinate& coordinate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_coordinate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void coordinate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.coordinate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* coordinate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<coordinate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required float x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // required float y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool coordinate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.coordinate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.coordinate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.coordinate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void coordinate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.coordinate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.coordinate)
}

size_t coordinate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.coordinate)
  size_t total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t coordinate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.coordinate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void coordinate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const coordinate*>(&from));
}

void coordinate::MergeFrom(const coordinate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.coordinate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void coordinate::CopyFrom(const coordinate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.coordinate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool coordinate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void coordinate::Swap(coordinate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void coordinate::InternalSwap(coordinate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
}

::std::string coordinate::GetTypeName() const {
  return "pb.coordinate";
}


// ===================================================================

void ellipseGate::InitAsDefaultInstance() {
  ::pb::_ellipseGate_default_instance_._instance.get_mutable()->mu_ = const_cast< ::pb::coordinate*>(
      ::pb::coordinate::internal_default_instance());
}
class ellipseGate::HasBitSetters {
 public:
  static const ::pb::coordinate& mu(const ellipseGate* msg);
  static void set_has_mu(ellipseGate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_dist(ellipseGate* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::pb::coordinate&
ellipseGate::HasBitSetters::mu(const ellipseGate* msg) {
  return *msg->mu_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ellipseGate::kMuFieldNumber;
const int ellipseGate::kCovFieldNumber;
const int ellipseGate::kAntipodalVerticesFieldNumber;
const int ellipseGate::kDistFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ellipseGate::ellipseGate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ellipseGate)
}
ellipseGate::ellipseGate(const ellipseGate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      cov_(from.cov_),
      antipodal_vertices_(from.antipodal_vertices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_mu()) {
    mu_ = new ::pb::coordinate(*from.mu_);
  } else {
    mu_ = nullptr;
  }
  dist_ = from.dist_;
  // @@protoc_insertion_point(copy_constructor:pb.ellipseGate)
}

void ellipseGate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ellipseGate_GatingSet_2eproto.base);
  ::memset(&mu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dist_) -
      reinterpret_cast<char*>(&mu_)) + sizeof(dist_));
}

ellipseGate::~ellipseGate() {
  // @@protoc_insertion_point(destructor:pb.ellipseGate)
  SharedDtor();
}

void ellipseGate::SharedDtor() {
  if (this != internal_default_instance()) delete mu_;
}

void ellipseGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ellipseGate& ellipseGate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ellipseGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void ellipseGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.ellipseGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cov_.Clear();
  antipodal_vertices_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(mu_ != nullptr);
    mu_->Clear();
  }
  dist_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ellipseGate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ellipseGate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .pb.coordinate mu = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::coordinate::_InternalParse;
        object = msg->mutable_mu();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // repeated .pb.coordinate cov = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::coordinate::_InternalParse;
          object = msg->add_cov();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // repeated .pb.coordinate antipodal_vertices = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::coordinate::_InternalParse;
          object = msg->add_antipodal_vertices();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      // optional float dist = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_dist(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ellipseGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.ellipseGate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .pb.coordinate mu = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_mu()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.coordinate cov = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_cov()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.coordinate antipodal_vertices = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_antipodal_vertices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float dist = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_dist(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dist_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ellipseGate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ellipseGate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ellipseGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ellipseGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.coordinate mu = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, HasBitSetters::mu(this), output);
  }

  // repeated .pb.coordinate cov = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->cov_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2,
      this->cov(static_cast<int>(i)),
      output);
  }

  // repeated .pb.coordinate antipodal_vertices = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->antipodal_vertices_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3,
      this->antipodal_vertices(static_cast<int>(i)),
      output);
  }

  // optional float dist = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->dist(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.ellipseGate)
}

size_t ellipseGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.ellipseGate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .pb.coordinate mu = 1;
  if (has_mu()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *mu_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.coordinate cov = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->cov_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->cov(static_cast<int>(i)));
    }
  }

  // repeated .pb.coordinate antipodal_vertices = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->antipodal_vertices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->antipodal_vertices(static_cast<int>(i)));
    }
  }

  // optional float dist = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ellipseGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ellipseGate*>(&from));
}

void ellipseGate::MergeFrom(const ellipseGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.ellipseGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cov_.MergeFrom(from.cov_);
  antipodal_vertices_.MergeFrom(from.antipodal_vertices_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_mu()->::pb::coordinate::MergeFrom(from.mu());
    }
    if (cached_has_bits & 0x00000002u) {
      dist_ = from.dist_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ellipseGate::CopyFrom(const ellipseGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.ellipseGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ellipseGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->cov())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->antipodal_vertices())) return false;
  if (has_mu()) {
    if (!this->mu_->IsInitialized()) return false;
  }
  return true;
}

void ellipseGate::Swap(ellipseGate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ellipseGate::InternalSwap(ellipseGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&cov_)->InternalSwap(CastToBase(&other->cov_));
  CastToBase(&antipodal_vertices_)->InternalSwap(CastToBase(&other->antipodal_vertices_));
  swap(mu_, other->mu_);
  swap(dist_, other->dist_);
}

::std::string ellipseGate::GetTypeName() const {
  return "pb.ellipseGate";
}


// ===================================================================

void BOOL_GATE_OP::InitAsDefaultInstance() {
}
class BOOL_GATE_OP::HasBitSetters {
 public:
  static void set_has_op(BOOL_GATE_OP* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_isnot(BOOL_GATE_OP* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BOOL_GATE_OP::kPathFieldNumber;
const int BOOL_GATE_OP::kOpFieldNumber;
const int BOOL_GATE_OP::kIsNotFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BOOL_GATE_OP::BOOL_GATE_OP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.BOOL_GATE_OP)
}
BOOL_GATE_OP::BOOL_GATE_OP(const BOOL_GATE_OP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      path_(from.path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&op_, &from.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&isnot_) -
    reinterpret_cast<char*>(&op_)) + sizeof(isnot_));
  // @@protoc_insertion_point(copy_constructor:pb.BOOL_GATE_OP)
}

void BOOL_GATE_OP::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BOOL_GATE_OP_GatingSet_2eproto.base);
  ::memset(&op_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isnot_) -
      reinterpret_cast<char*>(&op_)) + sizeof(isnot_));
}

BOOL_GATE_OP::~BOOL_GATE_OP() {
  // @@protoc_insertion_point(destructor:pb.BOOL_GATE_OP)
  SharedDtor();
}

void BOOL_GATE_OP::SharedDtor() {
}

void BOOL_GATE_OP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BOOL_GATE_OP& BOOL_GATE_OP::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BOOL_GATE_OP_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void BOOL_GATE_OP::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.BOOL_GATE_OP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&op_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isnot_) -
        reinterpret_cast<char*>(&op_)) + sizeof(isnot_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BOOL_GATE_OP::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BOOL_GATE_OP*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated string path = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_path();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // required uint32 op = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_op(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required bool isNot = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_isnot(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BOOL_GATE_OP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.BOOL_GATE_OP)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string path = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_path()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 op = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_op(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &op_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool isNot = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_isnot(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isnot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.BOOL_GATE_OP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.BOOL_GATE_OP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BOOL_GATE_OP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.BOOL_GATE_OP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string path = 1;
  for (int i = 0, n = this->path_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->path(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // required uint32 op = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->op(), output);
  }

  // required bool isNot = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isnot(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.BOOL_GATE_OP)
}

size_t BOOL_GATE_OP::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.BOOL_GATE_OP)
  size_t total_size = 0;

  if (has_op()) {
    // required uint32 op = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->op());
  }

  if (has_isnot()) {
    // required bool isNot = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t BOOL_GATE_OP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.BOOL_GATE_OP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 op = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->op());

    // required bool isNot = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string path = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->path_size());
  for (int i = 0, n = this->path_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->path(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BOOL_GATE_OP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BOOL_GATE_OP*>(&from));
}

void BOOL_GATE_OP::MergeFrom(const BOOL_GATE_OP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.BOOL_GATE_OP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  path_.MergeFrom(from.path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      op_ = from.op_;
    }
    if (cached_has_bits & 0x00000002u) {
      isnot_ = from.isnot_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BOOL_GATE_OP::CopyFrom(const BOOL_GATE_OP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.BOOL_GATE_OP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BOOL_GATE_OP::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void BOOL_GATE_OP::Swap(BOOL_GATE_OP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BOOL_GATE_OP::InternalSwap(BOOL_GATE_OP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  path_.InternalSwap(CastToBase(&other->path_));
  swap(op_, other->op_);
  swap(isnot_, other->isnot_);
}

::std::string BOOL_GATE_OP::GetTypeName() const {
  return "pb.BOOL_GATE_OP";
}


// ===================================================================

void boolGate::InitAsDefaultInstance() {
}
class boolGate::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int boolGate::kBoolOpSpecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

boolGate::boolGate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.boolGate)
}
boolGate::boolGate(const boolGate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      boolopspec_(from.boolopspec_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.boolGate)
}

void boolGate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_boolGate_GatingSet_2eproto.base);
}

boolGate::~boolGate() {
  // @@protoc_insertion_point(destructor:pb.boolGate)
  SharedDtor();
}

void boolGate::SharedDtor() {
}

void boolGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const boolGate& boolGate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_boolGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void boolGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.boolGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  boolopspec_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* boolGate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<boolGate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::BOOL_GATE_OP::_InternalParse;
          object = msg->add_boolopspec();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool boolGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.boolGate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_boolopspec()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.boolGate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.boolGate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void boolGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.boolGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->boolopspec_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->boolopspec(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.boolGate)
}

size_t boolGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.boolGate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.BOOL_GATE_OP boolOpSpec = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->boolopspec_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->boolopspec(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void boolGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const boolGate*>(&from));
}

void boolGate::MergeFrom(const boolGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.boolGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  boolopspec_.MergeFrom(from.boolopspec_);
}

void boolGate::CopyFrom(const boolGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.boolGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool boolGate::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->boolopspec())) return false;
  return true;
}

void boolGate::Swap(boolGate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void boolGate::InternalSwap(boolGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&boolopspec_)->InternalSwap(CastToBase(&other->boolopspec_));
}

::std::string boolGate::GetTypeName() const {
  return "pb.boolGate";
}


// ===================================================================

void clusterGate::InitAsDefaultInstance() {
}
class clusterGate::HasBitSetters {
 public:
  static void set_has_cluster_method(clusterGate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int clusterGate::kClusterMethodFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

clusterGate::clusterGate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.clusterGate)
}
clusterGate::clusterGate(const clusterGate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cluster_method_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_cluster_method()) {
    cluster_method_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cluster_method_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.clusterGate)
}

void clusterGate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_clusterGate_GatingSet_2eproto.base);
  cluster_method_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

clusterGate::~clusterGate() {
  // @@protoc_insertion_point(destructor:pb.clusterGate)
  SharedDtor();
}

void clusterGate::SharedDtor() {
  cluster_method_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void clusterGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const clusterGate& clusterGate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_clusterGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void clusterGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.clusterGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    cluster_method_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* clusterGate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<clusterGate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string cluster_method = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_cluster_method();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool clusterGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.clusterGate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string cluster_method = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cluster_method()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.clusterGate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.clusterGate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void clusterGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.clusterGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string cluster_method = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->cluster_method(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.clusterGate)
}

size_t clusterGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.clusterGate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string cluster_method = 1;
  if (has_cluster_method()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->cluster_method());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void clusterGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const clusterGate*>(&from));
}

void clusterGate::MergeFrom(const clusterGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.clusterGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_cluster_method()) {
    _has_bits_[0] |= 0x00000001u;
    cluster_method_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cluster_method_);
  }
}

void clusterGate::CopyFrom(const clusterGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.clusterGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool clusterGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void clusterGate::Swap(clusterGate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void clusterGate::InternalSwap(clusterGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cluster_method_.Swap(&other->cluster_method_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::std::string clusterGate::GetTypeName() const {
  return "pb.clusterGate";
}


// ===================================================================

void quadGate::InitAsDefaultInstance() {
}
class quadGate::HasBitSetters {
 public:
  static void set_has_uid(quadGate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_quadrant(quadGate* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int quadGate::kUidFieldNumber;
const int quadGate::kQuadrantFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

quadGate::quadGate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.quadGate)
}
quadGate::quadGate(const quadGate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  uid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_uid()) {
    uid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uid_);
  }
  quadrant_ = from.quadrant_;
  // @@protoc_insertion_point(copy_constructor:pb.quadGate)
}

void quadGate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_quadGate_GatingSet_2eproto.base);
  uid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quadrant_ = 1;
}

quadGate::~quadGate() {
  // @@protoc_insertion_point(destructor:pb.quadGate)
  SharedDtor();
}

void quadGate::SharedDtor() {
  uid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void quadGate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const quadGate& quadGate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_quadGate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void quadGate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.quadGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      uid_.ClearNonDefaultToEmptyNoArena();
    }
    quadrant_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* quadGate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<quadGate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string uid = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_uid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // required .pb.QUAD quadrant = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::pb::QUAD_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(3, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_quadrant(static_cast<::pb::QUAD>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool quadGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.quadGate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uid = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .pb.QUAD quadrant = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::QUAD_IsValid(value)) {
            set_quadrant(static_cast< ::pb::QUAD >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.quadGate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.quadGate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void quadGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.quadGate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string uid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->uid(), output);
  }

  // required .pb.QUAD quadrant = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->quadrant(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.quadGate)
}

size_t quadGate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.quadGate)
  size_t total_size = 0;

  if (has_uid()) {
    // required string uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->uid());
  }

  if (has_quadrant()) {
    // required .pb.QUAD quadrant = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->quadrant());
  }

  return total_size;
}
size_t quadGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.quadGate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->uid());

    // required .pb.QUAD quadrant = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->quadrant());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void quadGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const quadGate*>(&from));
}

void quadGate::MergeFrom(const quadGate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.quadGate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      uid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uid_);
    }
    if (cached_has_bits & 0x00000002u) {
      quadrant_ = from.quadrant_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void quadGate::CopyFrom(const quadGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.quadGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool quadGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void quadGate::Swap(quadGate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void quadGate::InternalSwap(quadGate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uid_.Swap(&other->uid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(quadrant_, other->quadrant_);
}

::std::string quadGate::GetTypeName() const {
  return "pb.quadGate";
}


// ===================================================================

void gate::InitAsDefaultInstance() {
  ::pb::_gate_default_instance_._instance.get_mutable()->rg_ = const_cast< ::pb::rangeGate*>(
      ::pb::rangeGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->pg_ = const_cast< ::pb::polygonGate*>(
      ::pb::polygonGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->eg_ = const_cast< ::pb::ellipseGate*>(
      ::pb::ellipseGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->bg_ = const_cast< ::pb::boolGate*>(
      ::pb::boolGate::internal_default_instance());
  ::pb::_gate_default_instance_._instance.get_mutable()->cg_ = const_cast< ::pb::clusterGate*>(
      ::pb::clusterGate::internal_default_instance());
}
class gate::HasBitSetters {
 public:
  static void set_has_neg(gate* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_istransformed(gate* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_isgained(gate* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_type(gate* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::pb::rangeGate& rg(const gate* msg);
  static void set_has_rg(gate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::pb::polygonGate& pg(const gate* msg);
  static void set_has_pg(gate* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::pb::ellipseGate& eg(const gate* msg);
  static void set_has_eg(gate* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::pb::boolGate& bg(const gate* msg);
  static void set_has_bg(gate* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::pb::clusterGate& cg(const gate* msg);
  static void set_has_cg(gate* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::pb::rangeGate&
gate::HasBitSetters::rg(const gate* msg) {
  return *msg->rg_;
}
const ::pb::polygonGate&
gate::HasBitSetters::pg(const gate* msg) {
  return *msg->pg_;
}
const ::pb::ellipseGate&
gate::HasBitSetters::eg(const gate* msg) {
  return *msg->eg_;
}
const ::pb::boolGate&
gate::HasBitSetters::bg(const gate* msg) {
  return *msg->bg_;
}
const ::pb::clusterGate&
gate::HasBitSetters::cg(const gate* msg) {
  return *msg->cg_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int gate::kNegFieldNumber;
const int gate::kIsTransformedFieldNumber;
const int gate::kIsGainedFieldNumber;
const int gate::kTypeFieldNumber;
const int gate::kRgFieldNumber;
const int gate::kPgFieldNumber;
const int gate::kEgFieldNumber;
const int gate::kBgFieldNumber;
const int gate::kCgFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

gate::gate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.gate)
}
gate::gate(const gate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_rg()) {
    rg_ = new ::pb::rangeGate(*from.rg_);
  } else {
    rg_ = nullptr;
  }
  if (from.has_pg()) {
    pg_ = new ::pb::polygonGate(*from.pg_);
  } else {
    pg_ = nullptr;
  }
  if (from.has_eg()) {
    eg_ = new ::pb::ellipseGate(*from.eg_);
  } else {
    eg_ = nullptr;
  }
  if (from.has_bg()) {
    bg_ = new ::pb::boolGate(*from.bg_);
  } else {
    bg_ = nullptr;
  }
  if (from.has_cg()) {
    cg_ = new ::pb::clusterGate(*from.cg_);
  } else {
    cg_ = nullptr;
  }
  ::memcpy(&neg_, &from.neg_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&neg_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:pb.gate)
}

void gate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_gate_GatingSet_2eproto.base);
  ::memset(&rg_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isgained_) -
      reinterpret_cast<char*>(&rg_)) + sizeof(isgained_));
  type_ = 1;
}

gate::~gate() {
  // @@protoc_insertion_point(destructor:pb.gate)
  SharedDtor();
}

void gate::SharedDtor() {
  if (this != internal_default_instance()) delete rg_;
  if (this != internal_default_instance()) delete pg_;
  if (this != internal_default_instance()) delete eg_;
  if (this != internal_default_instance()) delete bg_;
  if (this != internal_default_instance()) delete cg_;
}

void gate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const gate& gate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_gate_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void gate::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.gate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(rg_ != nullptr);
      rg_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pg_ != nullptr);
      pg_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(eg_ != nullptr);
      eg_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(bg_ != nullptr);
      bg_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(cg_ != nullptr);
      cg_->Clear();
    }
  }
  ::memset(&neg_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isgained_) -
      reinterpret_cast<char*>(&neg_)) + sizeof(isgained_));
  type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* gate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<gate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required bool neg = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_neg(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required bool isTransformed = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_istransformed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required bool isGained = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_isgained(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .pb.GATE_TYPE type = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::pb::GATE_TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(4, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::pb::GATE_TYPE>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.rangeGate rg = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::rangeGate::_InternalParse;
        object = msg->mutable_rg();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.polygonGate pg = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::polygonGate::_InternalParse;
        object = msg->mutable_pg();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.ellipseGate eg = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::ellipseGate::_InternalParse;
        object = msg->mutable_eg();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.boolGate bg = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::boolGate::_InternalParse;
        object = msg->mutable_bg();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.clusterGate cg = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::clusterGate::_InternalParse;
        object = msg->mutable_cg();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool gate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.gate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool neg = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_neg(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &neg_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool isTransformed = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_istransformed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &istransformed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool isGained = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_isgained(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isgained_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .pb.GATE_TYPE type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::GATE_TYPE_IsValid(value)) {
            set_type(static_cast< ::pb::GATE_TYPE >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.rangeGate rg = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_rg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.polygonGate pg = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.ellipseGate eg = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_eg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.boolGate bg = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.clusterGate cg = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.gate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.gate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void gate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.gate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool neg = 1;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->neg(), output);
  }

  // required bool isTransformed = 2;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->istransformed(), output);
  }

  // required bool isGained = 3;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isgained(), output);
  }

  // required .pb.GATE_TYPE type = 4;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional .pb.rangeGate rg = 5;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, HasBitSetters::rg(this), output);
  }

  // optional .pb.polygonGate pg = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, HasBitSetters::pg(this), output);
  }

  // optional .pb.ellipseGate eg = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, HasBitSetters::eg(this), output);
  }

  // optional .pb.boolGate bg = 8;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, HasBitSetters::bg(this), output);
  }

  // optional .pb.clusterGate cg = 9;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, HasBitSetters::cg(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.gate)
}

size_t gate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.gate)
  size_t total_size = 0;

  if (has_neg()) {
    // required bool neg = 1;
    total_size += 1 + 1;
  }

  if (has_istransformed()) {
    // required bool isTransformed = 2;
    total_size += 1 + 1;
  }

  if (has_isgained()) {
    // required bool isGained = 3;
    total_size += 1 + 1;
  }

  if (has_type()) {
    // required .pb.GATE_TYPE type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
size_t gate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.gate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x000001e0) ^ 0x000001e0) == 0) {  // All required fields are present.
    // required bool neg = 1;
    total_size += 1 + 1;

    // required bool isTransformed = 2;
    total_size += 1 + 1;

    // required bool isGained = 3;
    total_size += 1 + 1;

    // required .pb.GATE_TYPE type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .pb.rangeGate rg = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *rg_);
    }

    // optional .pb.polygonGate pg = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *pg_);
    }

    // optional .pb.ellipseGate eg = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *eg_);
    }

    // optional .pb.boolGate bg = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *bg_);
    }

    // optional .pb.clusterGate cg = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *cg_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void gate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const gate*>(&from));
}

void gate::MergeFrom(const gate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.gate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_rg()->::pb::rangeGate::MergeFrom(from.rg());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_pg()->::pb::polygonGate::MergeFrom(from.pg());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_eg()->::pb::ellipseGate::MergeFrom(from.eg());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_bg()->::pb::boolGate::MergeFrom(from.bg());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_cg()->::pb::clusterGate::MergeFrom(from.cg());
    }
    if (cached_has_bits & 0x00000020u) {
      neg_ = from.neg_;
    }
    if (cached_has_bits & 0x00000040u) {
      istransformed_ = from.istransformed_;
    }
    if (cached_has_bits & 0x00000080u) {
      isgained_ = from.isgained_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_type(from.type());
  }
}

void gate::CopyFrom(const gate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.gate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool gate::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001e0) != 0x000001e0) return false;
  if (has_rg()) {
    if (!this->rg_->IsInitialized()) return false;
  }
  if (has_pg()) {
    if (!this->pg_->IsInitialized()) return false;
  }
  if (has_eg()) {
    if (!this->eg_->IsInitialized()) return false;
  }
  if (has_bg()) {
    if (!this->bg_->IsInitialized()) return false;
  }
  if (has_cg()) {
    if (!this->cg_->IsInitialized()) return false;
  }
  return true;
}

void gate::Swap(gate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void gate::InternalSwap(gate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(rg_, other->rg_);
  swap(pg_, other->pg_);
  swap(eg_, other->eg_);
  swap(bg_, other->bg_);
  swap(cg_, other->cg_);
  swap(neg_, other->neg_);
  swap(istransformed_, other->istransformed_);
  swap(isgained_, other->isgained_);
  swap(type_, other->type_);
}

::std::string gate::GetTypeName() const {
  return "pb.gate";
}


// ===================================================================

void POPSTATS::InitAsDefaultInstance() {
}
class POPSTATS::HasBitSetters {
 public:
  static void set_has_stattype(POPSTATS* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_statval(POPSTATS* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int POPSTATS::kStatTypeFieldNumber;
const int POPSTATS::kStatValFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

POPSTATS::POPSTATS()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.POPSTATS)
}
POPSTATS::POPSTATS(const POPSTATS& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  stattype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_stattype()) {
    stattype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.stattype_);
  }
  statval_ = from.statval_;
  // @@protoc_insertion_point(copy_constructor:pb.POPSTATS)
}

void POPSTATS::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_POPSTATS_GatingSet_2eproto.base);
  stattype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  statval_ = 0;
}

POPSTATS::~POPSTATS() {
  // @@protoc_insertion_point(destructor:pb.POPSTATS)
  SharedDtor();
}

void POPSTATS::SharedDtor() {
  stattype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void POPSTATS::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const POPSTATS& POPSTATS::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_POPSTATS_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void POPSTATS::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.POPSTATS)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    stattype_.ClearNonDefaultToEmptyNoArena();
  }
  statval_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* POPSTATS::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<POPSTATS*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string statType = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_stattype();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // required float statVal = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_statval(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool POPSTATS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.POPSTATS)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string statType = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_stattype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float statVal = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_statval(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &statval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.POPSTATS)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.POPSTATS)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void POPSTATS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.POPSTATS)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string statType = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->stattype(), output);
  }

  // required float statVal = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->statval(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.POPSTATS)
}

size_t POPSTATS::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.POPSTATS)
  size_t total_size = 0;

  if (has_stattype()) {
    // required string statType = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->stattype());
  }

  if (has_statval()) {
    // required float statVal = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t POPSTATS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.POPSTATS)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string statType = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->stattype());

    // required float statVal = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void POPSTATS::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const POPSTATS*>(&from));
}

void POPSTATS::MergeFrom(const POPSTATS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.POPSTATS)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      stattype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.stattype_);
    }
    if (cached_has_bits & 0x00000002u) {
      statval_ = from.statval_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void POPSTATS::CopyFrom(const POPSTATS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.POPSTATS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool POPSTATS::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void POPSTATS::Swap(POPSTATS* other) {
  if (other == this) return;
  InternalSwap(other);
}
void POPSTATS::InternalSwap(POPSTATS* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stattype_.Swap(&other->stattype_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(statval_, other->statval_);
}

::std::string POPSTATS::GetTypeName() const {
  return "pb.POPSTATS";
}


// ===================================================================

void calibrationTable::InitAsDefaultInstance() {
}
class calibrationTable::HasBitSetters {
 public:
  static void set_has_spline_method(calibrationTable* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_caltype(calibrationTable* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_flag(calibrationTable* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int calibrationTable::kXFieldNumber;
const int calibrationTable::kYFieldNumber;
const int calibrationTable::kBFieldNumber;
const int calibrationTable::kCFieldNumber;
const int calibrationTable::kDFieldNumber;
const int calibrationTable::kSplineMethodFieldNumber;
const int calibrationTable::kCaltypeFieldNumber;
const int calibrationTable::kFlagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

calibrationTable::calibrationTable()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.calibrationTable)
}
calibrationTable::calibrationTable(const calibrationTable& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      x_(from.x_),
      y_(from.y_),
      b_(from.b_),
      c_(from.c_),
      d_(from.d_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  caltype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_caltype()) {
    caltype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.caltype_);
  }
  ::memcpy(&spline_method_, &from.spline_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&spline_method_)) + sizeof(flag_));
  // @@protoc_insertion_point(copy_constructor:pb.calibrationTable)
}

void calibrationTable::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_calibrationTable_GatingSet_2eproto.base);
  caltype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&spline_method_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flag_) -
      reinterpret_cast<char*>(&spline_method_)) + sizeof(flag_));
}

calibrationTable::~calibrationTable() {
  // @@protoc_insertion_point(destructor:pb.calibrationTable)
  SharedDtor();
}

void calibrationTable::SharedDtor() {
  caltype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void calibrationTable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const calibrationTable& calibrationTable::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_calibrationTable_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void calibrationTable::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.calibrationTable)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  x_.Clear();
  y_.Clear();
  b_.Clear();
  c_.Clear();
  d_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    caltype_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&spline_method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flag_) -
        reinterpret_cast<char*>(&spline_method_)) + sizeof(flag_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* calibrationTable::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<calibrationTable*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated float x = 1 [packed = true];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 10) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedFloatParser;
          object = msg->mutable_x();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        do {
          msg->add_x(::google::protobuf::io::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 13 && (ptr += 1));
        break;
      }
      // repeated float y = 2 [packed = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 18) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedFloatParser;
          object = msg->mutable_y();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        do {
          msg->add_y(::google::protobuf::io::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 21 && (ptr += 1));
        break;
      }
      // repeated float b = 3 [packed = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 26) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedFloatParser;
          object = msg->mutable_b();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        do {
          msg->add_b(::google::protobuf::io::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 29 && (ptr += 1));
        break;
      }
      // repeated float c = 4 [packed = true];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) == 34) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedFloatParser;
          object = msg->mutable_c();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        do {
          msg->add_c(::google::protobuf::io::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 37 && (ptr += 1));
        break;
      }
      // repeated float d = 5 [packed = true];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) == 42) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedFloatParser;
          object = msg->mutable_d();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        do {
          msg->add_d(::google::protobuf::io::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 45 && (ptr += 1));
        break;
      }
      // optional uint32 spline_method = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_spline_method(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string caltype = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_caltype();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bool flag = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_flag(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool calibrationTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.calibrationTable)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float x = 1 [packed = true];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_x())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 10u, input, this->mutable_x())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float y = 2 [packed = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_y())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 18u, input, this->mutable_y())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float b = 3 [packed = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_b())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 26u, input, this->mutable_b())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float c = 4 [packed = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_c())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 34u, input, this->mutable_c())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float d = 5 [packed = true];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_d())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 42u, input, this->mutable_d())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 spline_method = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_spline_method(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &spline_method_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string caltype = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_caltype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool flag = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_flag(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.calibrationTable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.calibrationTable)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void calibrationTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.calibrationTable)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float x = 1 [packed = true];
  if (this->x_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_x_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->x().data(), this->x_size(), output);
  }

  // repeated float y = 2 [packed = true];
  if (this->y_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_y_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->y().data(), this->y_size(), output);
  }

  // repeated float b = 3 [packed = true];
  if (this->b_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_b_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->b().data(), this->b_size(), output);
  }

  // repeated float c = 4 [packed = true];
  if (this->c_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_c_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->c().data(), this->c_size(), output);
  }

  // repeated float d = 5 [packed = true];
  if (this->d_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_d_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->d().data(), this->d_size(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 spline_method = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->spline_method(), output);
  }

  // optional string caltype = 7;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->caltype(), output);
  }

  // optional bool flag = 8;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->flag(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.calibrationTable)
}

size_t calibrationTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.calibrationTable)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float x = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->x_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _x_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float y = 2 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->y_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _y_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float b = 3 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->b_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _b_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float c = 4 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->c_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _c_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float d = 5 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->d_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _d_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string caltype = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->caltype());
    }

    // optional uint32 spline_method = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->spline_method());
    }

    // optional bool flag = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void calibrationTable::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const calibrationTable*>(&from));
}

void calibrationTable::MergeFrom(const calibrationTable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.calibrationTable)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  x_.MergeFrom(from.x_);
  y_.MergeFrom(from.y_);
  b_.MergeFrom(from.b_);
  c_.MergeFrom(from.c_);
  d_.MergeFrom(from.d_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      caltype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.caltype_);
    }
    if (cached_has_bits & 0x00000002u) {
      spline_method_ = from.spline_method_;
    }
    if (cached_has_bits & 0x00000004u) {
      flag_ = from.flag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void calibrationTable::CopyFrom(const calibrationTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.calibrationTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool calibrationTable::IsInitialized() const {
  return true;
}

void calibrationTable::Swap(calibrationTable* other) {
  if (other == this) return;
  InternalSwap(other);
}
void calibrationTable::InternalSwap(calibrationTable* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  x_.InternalSwap(&other->x_);
  y_.InternalSwap(&other->y_);
  b_.InternalSwap(&other->b_);
  c_.InternalSwap(&other->c_);
  d_.InternalSwap(&other->d_);
  caltype_.Swap(&other->caltype_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(spline_method_, other->spline_method_);
  swap(flag_, other->flag_);
}

::std::string calibrationTable::GetTypeName() const {
  return "pb.calibrationTable";
}


// ===================================================================

void biexpTrans::InitAsDefaultInstance() {
}
class biexpTrans::HasBitSetters {
 public:
  static void set_has_channelrange(biexpTrans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_pos(biexpTrans* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_neg(biexpTrans* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_widthbasis(biexpTrans* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_maxvalue(biexpTrans* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int biexpTrans::kChannelRangeFieldNumber;
const int biexpTrans::kPosFieldNumber;
const int biexpTrans::kNegFieldNumber;
const int biexpTrans::kWidthBasisFieldNumber;
const int biexpTrans::kMaxValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

biexpTrans::biexpTrans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.biexpTrans)
}
biexpTrans::biexpTrans(const biexpTrans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&channelrange_, &from.channelrange_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&channelrange_)) + sizeof(maxvalue_));
  // @@protoc_insertion_point(copy_constructor:pb.biexpTrans)
}

void biexpTrans::SharedCtor() {
  ::memset(&channelrange_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxvalue_) -
      reinterpret_cast<char*>(&channelrange_)) + sizeof(maxvalue_));
}

biexpTrans::~biexpTrans() {
  // @@protoc_insertion_point(destructor:pb.biexpTrans)
  SharedDtor();
}

void biexpTrans::SharedDtor() {
}

void biexpTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const biexpTrans& biexpTrans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_biexpTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void biexpTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.biexpTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&channelrange_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&maxvalue_) -
        reinterpret_cast<char*>(&channelrange_)) + sizeof(maxvalue_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* biexpTrans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<biexpTrans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 channelRange = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_channelrange(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float pos = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_pos(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float neg = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_neg(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float widthBasis = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_widthbasis(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float maxValue = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_maxvalue(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool biexpTrans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.biexpTrans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 channelRange = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_channelrange(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channelrange_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float pos = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_pos(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float neg = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_neg(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &neg_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float widthBasis = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_widthbasis(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &widthbasis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float maxValue = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_maxvalue(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maxvalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.biexpTrans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.biexpTrans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void biexpTrans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.biexpTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 channelRange = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->channelrange(), output);
  }

  // optional float pos = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->pos(), output);
  }

  // optional float neg = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->neg(), output);
  }

  // optional float widthBasis = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->widthbasis(), output);
  }

  // optional float maxValue = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->maxvalue(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.biexpTrans)
}

size_t biexpTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.biexpTrans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 channelRange = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->channelrange());
    }

    // optional float pos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float neg = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float widthBasis = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float maxValue = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void biexpTrans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const biexpTrans*>(&from));
}

void biexpTrans::MergeFrom(const biexpTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.biexpTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      channelrange_ = from.channelrange_;
    }
    if (cached_has_bits & 0x00000002u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000004u) {
      neg_ = from.neg_;
    }
    if (cached_has_bits & 0x00000008u) {
      widthbasis_ = from.widthbasis_;
    }
    if (cached_has_bits & 0x00000010u) {
      maxvalue_ = from.maxvalue_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void biexpTrans::CopyFrom(const biexpTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.biexpTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool biexpTrans::IsInitialized() const {
  return true;
}

void biexpTrans::Swap(biexpTrans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void biexpTrans::InternalSwap(biexpTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(channelrange_, other->channelrange_);
  swap(pos_, other->pos_);
  swap(neg_, other->neg_);
  swap(widthbasis_, other->widthbasis_);
  swap(maxvalue_, other->maxvalue_);
}

::std::string biexpTrans::GetTypeName() const {
  return "pb.biexpTrans";
}


// ===================================================================

void fasinhTrans::InitAsDefaultInstance() {
}
class fasinhTrans::HasBitSetters {
 public:
  static void set_has_length(fasinhTrans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_maxrange(fasinhTrans* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_t(fasinhTrans* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_a(fasinhTrans* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_m(fasinhTrans* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int fasinhTrans::kLengthFieldNumber;
const int fasinhTrans::kMaxRangeFieldNumber;
const int fasinhTrans::kTFieldNumber;
const int fasinhTrans::kAFieldNumber;
const int fasinhTrans::kMFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

fasinhTrans::fasinhTrans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.fasinhTrans)
}
fasinhTrans::fasinhTrans(const fasinhTrans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&length_, &from.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_) -
    reinterpret_cast<char*>(&length_)) + sizeof(m_));
  // @@protoc_insertion_point(copy_constructor:pb.fasinhTrans)
}

void fasinhTrans::SharedCtor() {
  ::memset(&length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_) -
      reinterpret_cast<char*>(&length_)) + sizeof(m_));
}

fasinhTrans::~fasinhTrans() {
  // @@protoc_insertion_point(destructor:pb.fasinhTrans)
  SharedDtor();
}

void fasinhTrans::SharedDtor() {
}

void fasinhTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const fasinhTrans& fasinhTrans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_fasinhTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void fasinhTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.fasinhTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&m_) -
        reinterpret_cast<char*>(&length_)) + sizeof(m_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* fasinhTrans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<fasinhTrans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float length = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_length(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float maxRange = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_maxrange(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float T = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_t(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float A = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_a(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float M = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_m(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool fasinhTrans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.fasinhTrans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float length = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float maxRange = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_maxrange(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maxrange_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float T = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_t(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &t_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float A = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_a(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &a_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float M = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_m(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.fasinhTrans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.fasinhTrans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void fasinhTrans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.fasinhTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float length = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->length(), output);
  }

  // optional float maxRange = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->maxrange(), output);
  }

  // optional float T = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->t(), output);
  }

  // optional float A = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->a(), output);
  }

  // optional float M = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->m(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.fasinhTrans)
}

size_t fasinhTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.fasinhTrans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float length = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float maxRange = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float T = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float A = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float M = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void fasinhTrans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const fasinhTrans*>(&from));
}

void fasinhTrans::MergeFrom(const fasinhTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.fasinhTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000002u) {
      maxrange_ = from.maxrange_;
    }
    if (cached_has_bits & 0x00000004u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000008u) {
      a_ = from.a_;
    }
    if (cached_has_bits & 0x00000010u) {
      m_ = from.m_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void fasinhTrans::CopyFrom(const fasinhTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.fasinhTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fasinhTrans::IsInitialized() const {
  return true;
}

void fasinhTrans::Swap(fasinhTrans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void fasinhTrans::InternalSwap(fasinhTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(length_, other->length_);
  swap(maxrange_, other->maxrange_);
  swap(t_, other->t_);
  swap(a_, other->a_);
  swap(m_, other->m_);
}

::std::string fasinhTrans::GetTypeName() const {
  return "pb.fasinhTrans";
}


// ===================================================================

void scaleTrans::InitAsDefaultInstance() {
}
class scaleTrans::HasBitSetters {
 public:
  static void set_has_scale_factor(scaleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int scaleTrans::kScaleFactorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

scaleTrans::scaleTrans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.scaleTrans)
}
scaleTrans::scaleTrans(const scaleTrans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  scale_factor_ = from.scale_factor_;
  // @@protoc_insertion_point(copy_constructor:pb.scaleTrans)
}

void scaleTrans::SharedCtor() {
  scale_factor_ = 0;
}

scaleTrans::~scaleTrans() {
  // @@protoc_insertion_point(destructor:pb.scaleTrans)
  SharedDtor();
}

void scaleTrans::SharedDtor() {
}

void scaleTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const scaleTrans& scaleTrans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_scaleTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void scaleTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.scaleTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  scale_factor_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* scaleTrans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<scaleTrans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float scale_factor = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_scale_factor(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool scaleTrans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.scaleTrans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float scale_factor = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_scale_factor(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_factor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.scaleTrans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.scaleTrans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void scaleTrans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.scaleTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float scale_factor = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->scale_factor(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.scaleTrans)
}

size_t scaleTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.scaleTrans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float scale_factor = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void scaleTrans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const scaleTrans*>(&from));
}

void scaleTrans::MergeFrom(const scaleTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.scaleTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_scale_factor()) {
    set_scale_factor(from.scale_factor());
  }
}

void scaleTrans::CopyFrom(const scaleTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.scaleTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool scaleTrans::IsInitialized() const {
  return true;
}

void scaleTrans::Swap(scaleTrans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void scaleTrans::InternalSwap(scaleTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(scale_factor_, other->scale_factor_);
}

::std::string scaleTrans::GetTypeName() const {
  return "pb.scaleTrans";
}


// ===================================================================

void flinTrans::InitAsDefaultInstance() {
}
class flinTrans::HasBitSetters {
 public:
  static void set_has_min(flinTrans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_max(flinTrans* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int flinTrans::kMinFieldNumber;
const int flinTrans::kMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

flinTrans::flinTrans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.flinTrans)
}
flinTrans::flinTrans(const flinTrans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&min_, &from.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&min_)) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:pb.flinTrans)
}

void flinTrans::SharedCtor() {
  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
}

flinTrans::~flinTrans() {
  // @@protoc_insertion_point(destructor:pb.flinTrans)
  SharedDtor();
}

void flinTrans::SharedDtor() {
}

void flinTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const flinTrans& flinTrans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_flinTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void flinTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.flinTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_) -
        reinterpret_cast<char*>(&min_)) + sizeof(max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* flinTrans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<flinTrans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float min = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_min(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float max = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_max(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool flinTrans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.flinTrans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float min = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_min(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float max = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_max(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.flinTrans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.flinTrans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void flinTrans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.flinTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float min = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->min(), output);
  }

  // optional float max = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->max(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.flinTrans)
}

size_t flinTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.flinTrans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float min = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void flinTrans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const flinTrans*>(&from));
}

void flinTrans::MergeFrom(const flinTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.flinTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      min_ = from.min_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_ = from.max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void flinTrans::CopyFrom(const flinTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.flinTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool flinTrans::IsInitialized() const {
  return true;
}

void flinTrans::Swap(flinTrans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void flinTrans::InternalSwap(flinTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(min_, other->min_);
  swap(max_, other->max_);
}

::std::string flinTrans::GetTypeName() const {
  return "pb.flinTrans";
}


// ===================================================================

void logTrans::InitAsDefaultInstance() {
}
class logTrans::HasBitSetters {
 public:
  static void set_has_offset(logTrans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_decade(logTrans* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_t(logTrans* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_scale(logTrans* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int logTrans::kOffsetFieldNumber;
const int logTrans::kDecadeFieldNumber;
const int logTrans::kTFieldNumber;
const int logTrans::kScaleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

logTrans::logTrans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.logTrans)
}
logTrans::logTrans(const logTrans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(scale_));
  // @@protoc_insertion_point(copy_constructor:pb.logTrans)
}

void logTrans::SharedCtor() {
  ::memset(&offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_) -
      reinterpret_cast<char*>(&offset_)) + sizeof(scale_));
}

logTrans::~logTrans() {
  // @@protoc_insertion_point(destructor:pb.logTrans)
  SharedDtor();
}

void logTrans::SharedDtor() {
}

void logTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const logTrans& logTrans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_logTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void logTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.logTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scale_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(scale_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* logTrans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<logTrans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float offset = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_offset(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float decade = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_decade(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float T = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_t(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float scale = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool logTrans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.logTrans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float offset = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_offset(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float decade = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_decade(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &decade_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float T = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_t(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &t_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.logTrans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.logTrans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void logTrans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.logTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float offset = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->offset(), output);
  }

  // optional float decade = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->decade(), output);
  }

  // optional float T = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->t(), output);
  }

  // optional float scale = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->scale(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.logTrans)
}

size_t logTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.logTrans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional float offset = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float decade = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float T = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float scale = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void logTrans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const logTrans*>(&from));
}

void logTrans::MergeFrom(const logTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.logTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      decade_ = from.decade_;
    }
    if (cached_has_bits & 0x00000004u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000008u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void logTrans::CopyFrom(const logTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.logTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool logTrans::IsInitialized() const {
  return true;
}

void logTrans::Swap(logTrans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void logTrans::InternalSwap(logTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(offset_, other->offset_);
  swap(decade_, other->decade_);
  swap(t_, other->t_);
  swap(scale_, other->scale_);
}

::std::string logTrans::GetTypeName() const {
  return "pb.logTrans";
}


// ===================================================================

void logGML2Trans::InitAsDefaultInstance() {
}
class logGML2Trans::HasBitSetters {
 public:
  static void set_has_t(logGML2Trans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_m(logGML2Trans* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int logGML2Trans::kTFieldNumber;
const int logGML2Trans::kMFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

logGML2Trans::logGML2Trans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.logGML2Trans)
}
logGML2Trans::logGML2Trans(const logGML2Trans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&t_, &from.t_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_) -
    reinterpret_cast<char*>(&t_)) + sizeof(m_));
  // @@protoc_insertion_point(copy_constructor:pb.logGML2Trans)
}

void logGML2Trans::SharedCtor() {
  ::memset(&t_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_) -
      reinterpret_cast<char*>(&t_)) + sizeof(m_));
}

logGML2Trans::~logGML2Trans() {
  // @@protoc_insertion_point(destructor:pb.logGML2Trans)
  SharedDtor();
}

void logGML2Trans::SharedDtor() {
}

void logGML2Trans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const logGML2Trans& logGML2Trans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_logGML2Trans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void logGML2Trans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.logGML2Trans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&t_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&m_) -
        reinterpret_cast<char*>(&t_)) + sizeof(m_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* logGML2Trans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<logGML2Trans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float T = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_t(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float M = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_m(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool logGML2Trans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.logGML2Trans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float T = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_t(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &t_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float M = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_m(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.logGML2Trans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.logGML2Trans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void logGML2Trans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.logGML2Trans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float T = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->t(), output);
  }

  // optional float M = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->m(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.logGML2Trans)
}

size_t logGML2Trans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.logGML2Trans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float T = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float M = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void logGML2Trans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const logGML2Trans*>(&from));
}

void logGML2Trans::MergeFrom(const logGML2Trans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.logGML2Trans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000002u) {
      m_ = from.m_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void logGML2Trans::CopyFrom(const logGML2Trans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.logGML2Trans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool logGML2Trans::IsInitialized() const {
  return true;
}

void logGML2Trans::Swap(logGML2Trans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void logGML2Trans::InternalSwap(logGML2Trans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(t_, other->t_);
  swap(m_, other->m_);
}

::std::string logGML2Trans::GetTypeName() const {
  return "pb.logGML2Trans";
}


// ===================================================================

void logicleTrans::InitAsDefaultInstance() {
}
class logicleTrans::HasBitSetters {
 public:
  static void set_has_t(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_w(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_m(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_a(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_bins(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_isgml2(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_isinverse(logicleTrans* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int logicleTrans::kTFieldNumber;
const int logicleTrans::kWFieldNumber;
const int logicleTrans::kMFieldNumber;
const int logicleTrans::kAFieldNumber;
const int logicleTrans::kBinsFieldNumber;
const int logicleTrans::kIsGml2FieldNumber;
const int logicleTrans::kIsInverseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

logicleTrans::logicleTrans()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.logicleTrans)
}
logicleTrans::logicleTrans(const logicleTrans& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&t_, &from.t_,
    static_cast<size_t>(reinterpret_cast<char*>(&isinverse_) -
    reinterpret_cast<char*>(&t_)) + sizeof(isinverse_));
  // @@protoc_insertion_point(copy_constructor:pb.logicleTrans)
}

void logicleTrans::SharedCtor() {
  ::memset(&t_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isinverse_) -
      reinterpret_cast<char*>(&t_)) + sizeof(isinverse_));
}

logicleTrans::~logicleTrans() {
  // @@protoc_insertion_point(destructor:pb.logicleTrans)
  SharedDtor();
}

void logicleTrans::SharedDtor() {
}

void logicleTrans::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const logicleTrans& logicleTrans::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_logicleTrans_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void logicleTrans::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.logicleTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&t_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isinverse_) -
        reinterpret_cast<char*>(&t_)) + sizeof(isinverse_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* logicleTrans::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<logicleTrans*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float T = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_t(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float W = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_w(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float M = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_m(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float A = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_a(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float bins = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_bins(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional bool isGml2 = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_isgml2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool isInverse = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_isinverse(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool logicleTrans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.logicleTrans)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float T = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_t(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &t_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float W = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_w(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &w_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float M = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_m(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float A = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_a(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &a_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float bins = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_bins(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bins_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool isGml2 = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_isgml2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isgml2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool isInverse = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_isinverse(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isinverse_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.logicleTrans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.logicleTrans)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void logicleTrans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.logicleTrans)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float T = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->t(), output);
  }

  // optional float W = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->w(), output);
  }

  // optional float M = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->m(), output);
  }

  // optional float A = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->a(), output);
  }

  // optional float bins = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->bins(), output);
  }

  // optional bool isGml2 = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->isgml2(), output);
  }

  // optional bool isInverse = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->isinverse(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.logicleTrans)
}

size_t logicleTrans::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.logicleTrans)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional float T = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float W = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float M = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float A = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float bins = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool isGml2 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool isInverse = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void logicleTrans::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const logicleTrans*>(&from));
}

void logicleTrans::MergeFrom(const logicleTrans& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.logicleTrans)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      t_ = from.t_;
    }
    if (cached_has_bits & 0x00000002u) {
      w_ = from.w_;
    }
    if (cached_has_bits & 0x00000004u) {
      m_ = from.m_;
    }
    if (cached_has_bits & 0x00000008u) {
      a_ = from.a_;
    }
    if (cached_has_bits & 0x00000010u) {
      bins_ = from.bins_;
    }
    if (cached_has_bits & 0x00000020u) {
      isgml2_ = from.isgml2_;
    }
    if (cached_has_bits & 0x00000040u) {
      isinverse_ = from.isinverse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void logicleTrans::CopyFrom(const logicleTrans& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.logicleTrans)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool logicleTrans::IsInitialized() const {
  return true;
}

void logicleTrans::Swap(logicleTrans* other) {
  if (other == this) return;
  InternalSwap(other);
}
void logicleTrans::InternalSwap(logicleTrans* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(t_, other->t_);
  swap(w_, other->w_);
  swap(m_, other->m_);
  swap(a_, other->a_);
  swap(bins_, other->bins_);
  swap(isgml2_, other->isgml2_);
  swap(isinverse_, other->isinverse_);
}

::std::string logicleTrans::GetTypeName() const {
  return "pb.logicleTrans";
}


// ===================================================================

void transformation::InitAsDefaultInstance() {
  ::pb::_transformation_default_instance_._instance.get_mutable()->caltbl_ = const_cast< ::pb::calibrationTable*>(
      ::pb::calibrationTable::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->bt_ = const_cast< ::pb::biexpTrans*>(
      ::pb::biexpTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->lt_ = const_cast< ::pb::logTrans*>(
      ::pb::logTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->flt_ = const_cast< ::pb::flinTrans*>(
      ::pb::flinTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->st_ = const_cast< ::pb::scaleTrans*>(
      ::pb::scaleTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->ft_ = const_cast< ::pb::fasinhTrans*>(
      ::pb::fasinhTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->lgt_ = const_cast< ::pb::logicleTrans*>(
      ::pb::logicleTrans::internal_default_instance());
  ::pb::_transformation_default_instance_._instance.get_mutable()->lgml2t_ = const_cast< ::pb::logGML2Trans*>(
      ::pb::logGML2Trans::internal_default_instance());
}
class transformation::HasBitSetters {
 public:
  static const ::pb::calibrationTable& caltbl(const transformation* msg);
  static void set_has_caltbl(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_isgateonly(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_name(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_channel(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_iscomputed(transformation* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_type(transformation* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_trans_type(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static const ::pb::biexpTrans& bt(const transformation* msg);
  static void set_has_bt(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::pb::logTrans& lt(const transformation* msg);
  static void set_has_lt(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::pb::flinTrans& flt(const transformation* msg);
  static void set_has_flt(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::pb::scaleTrans& st(const transformation* msg);
  static void set_has_st(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static const ::pb::fasinhTrans& ft(const transformation* msg);
  static void set_has_ft(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static const ::pb::logicleTrans& lgt(const transformation* msg);
  static void set_has_lgt(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::pb::logGML2Trans& lgml2t(const transformation* msg);
  static void set_has_lgml2t(transformation* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

const ::pb::calibrationTable&
transformation::HasBitSetters::caltbl(const transformation* msg) {
  return *msg->caltbl_;
}
const ::pb::biexpTrans&
transformation::HasBitSetters::bt(const transformation* msg) {
  return *msg->bt_;
}
const ::pb::logTrans&
transformation::HasBitSetters::lt(const transformation* msg) {
  return *msg->lt_;
}
const ::pb::flinTrans&
transformation::HasBitSetters::flt(const transformation* msg) {
  return *msg->flt_;
}
const ::pb::scaleTrans&
transformation::HasBitSetters::st(const transformation* msg) {
  return *msg->st_;
}
const ::pb::fasinhTrans&
transformation::HasBitSetters::ft(const transformation* msg) {
  return *msg->ft_;
}
const ::pb::logicleTrans&
transformation::HasBitSetters::lgt(const transformation* msg) {
  return *msg->lgt_;
}
const ::pb::logGML2Trans&
transformation::HasBitSetters::lgml2t(const transformation* msg) {
  return *msg->lgml2t_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int transformation::kCalTblFieldNumber;
const int transformation::kIsGateOnlyFieldNumber;
const int transformation::kNameFieldNumber;
const int transformation::kChannelFieldNumber;
const int transformation::kIsComputedFieldNumber;
const int transformation::kTypeFieldNumber;
const int transformation::kTransTypeFieldNumber;
const int transformation::kBtFieldNumber;
const int transformation::kLtFieldNumber;
const int transformation::kFltFieldNumber;
const int transformation::kStFieldNumber;
const int transformation::kFtFieldNumber;
const int transformation::kLgtFieldNumber;
const int transformation::kLgml2TFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

transformation::transformation()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.transformation)
}
transformation::transformation(const transformation& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  channel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_channel()) {
    channel_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.channel_);
  }
  if (from.has_caltbl()) {
    caltbl_ = new ::pb::calibrationTable(*from.caltbl_);
  } else {
    caltbl_ = nullptr;
  }
  if (from.has_bt()) {
    bt_ = new ::pb::biexpTrans(*from.bt_);
  } else {
    bt_ = nullptr;
  }
  if (from.has_lt()) {
    lt_ = new ::pb::logTrans(*from.lt_);
  } else {
    lt_ = nullptr;
  }
  if (from.has_flt()) {
    flt_ = new ::pb::flinTrans(*from.flt_);
  } else {
    flt_ = nullptr;
  }
  if (from.has_st()) {
    st_ = new ::pb::scaleTrans(*from.st_);
  } else {
    st_ = nullptr;
  }
  if (from.has_ft()) {
    ft_ = new ::pb::fasinhTrans(*from.ft_);
  } else {
    ft_ = nullptr;
  }
  if (from.has_lgt()) {
    lgt_ = new ::pb::logicleTrans(*from.lgt_);
  } else {
    lgt_ = nullptr;
  }
  if (from.has_lgml2t()) {
    lgml2t_ = new ::pb::logGML2Trans(*from.lgml2t_);
  } else {
    lgml2t_ = nullptr;
  }
  ::memcpy(&trans_type_, &from.trans_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&trans_type_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:pb.transformation)
}

void transformation::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_transformation_GatingSet_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  channel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&caltbl_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&caltbl_)) + sizeof(type_));
}

transformation::~transformation() {
  // @@protoc_insertion_point(destructor:pb.transformation)
  SharedDtor();
}

void transformation::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  channel_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete caltbl_;
  if (this != internal_default_instance()) delete bt_;
  if (this != internal_default_instance()) delete lt_;
  if (this != internal_default_instance()) delete flt_;
  if (this != internal_default_instance()) delete st_;
  if (this != internal_default_instance()) delete ft_;
  if (this != internal_default_instance()) delete lgt_;
  if (this != internal_default_instance()) delete lgml2t_;
}

void transformation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const transformation& transformation::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_transformation_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void transformation::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.transformation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      channel_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(caltbl_ != nullptr);
      caltbl_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(bt_ != nullptr);
      bt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(lt_ != nullptr);
      lt_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(flt_ != nullptr);
      flt_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(st_ != nullptr);
      st_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(ft_ != nullptr);
      ft_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(lgt_ != nullptr);
      lgt_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(lgml2t_ != nullptr);
      lgml2t_->Clear();
    }
  }
  if (cached_has_bits & 0x00003c00u) {
    ::memset(&trans_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&trans_type_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* transformation::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<transformation*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .pb.calibrationTable calTbl = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::calibrationTable::_InternalParse;
        object = msg->mutable_caltbl();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool isGateOnly = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_isgateonly(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.TRANS_TYPE trans_type = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::pb::TRANS_TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(3, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_trans_type(static_cast<::pb::TRANS_TYPE>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string name = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string channel = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_channel();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bool isComputed = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_iscomputed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.biexpTrans bt = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::biexpTrans::_InternalParse;
        object = msg->mutable_bt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.logTrans lt = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::logTrans::_InternalParse;
        object = msg->mutable_lt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.flinTrans flt = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::flinTrans::_InternalParse;
        object = msg->mutable_flt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.scaleTrans st = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::scaleTrans::_InternalParse;
        object = msg->mutable_st();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.fasinhTrans ft = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::fasinhTrans::_InternalParse;
        object = msg->mutable_ft();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 type = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.logicleTrans lgt = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 106) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::logicleTrans::_InternalParse;
        object = msg->mutable_lgt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.logGML2Trans lgml2t = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 114) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::logGML2Trans::_InternalParse;
        object = msg->mutable_lgml2t();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool transformation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.transformation)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pb.calibrationTable calTbl = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_caltbl()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool isGateOnly = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_isgateonly(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isgateonly_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.TRANS_TYPE trans_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::TRANS_TYPE_IsValid(value)) {
            set_trans_type(static_cast< ::pb::TRANS_TYPE >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string channel = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_channel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool isComputed = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_iscomputed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iscomputed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.biexpTrans bt = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.logTrans lt = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.flinTrans flt = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_flt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.scaleTrans st = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (82 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_st()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.fasinhTrans ft = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_ft()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 type = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.logicleTrans lgt = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (106 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lgt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.logGML2Trans lgml2t = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (114 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lgml2t()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.transformation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.transformation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void transformation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.transformation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pb.calibrationTable calTbl = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, HasBitSetters::caltbl(this), output);
  }

  // optional bool isGateOnly = 2;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isgateonly(), output);
  }

  // optional .pb.TRANS_TYPE trans_type = 3;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->trans_type(), output);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->name(), output);
  }

  // optional string channel = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->channel(), output);
  }

  // optional bool isComputed = 6;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->iscomputed(), output);
  }

  // optional .pb.biexpTrans bt = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, HasBitSetters::bt(this), output);
  }

  // optional .pb.logTrans lt = 8;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, HasBitSetters::lt(this), output);
  }

  // optional .pb.flinTrans flt = 9;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, HasBitSetters::flt(this), output);
  }

  // optional .pb.scaleTrans st = 10;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, HasBitSetters::st(this), output);
  }

  // optional .pb.fasinhTrans ft = 11;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, HasBitSetters::ft(this), output);
  }

  // optional uint32 type = 12;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->type(), output);
  }

  // optional .pb.logicleTrans lgt = 13;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, HasBitSetters::lgt(this), output);
  }

  // optional .pb.logGML2Trans lgml2t = 14;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, HasBitSetters::lgml2t(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.transformation)
}

size_t transformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.transformation)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string channel = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channel());
    }

    // optional .pb.calibrationTable calTbl = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *caltbl_);
    }

    // optional .pb.biexpTrans bt = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *bt_);
    }

    // optional .pb.logTrans lt = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lt_);
    }

    // optional .pb.flinTrans flt = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *flt_);
    }

    // optional .pb.scaleTrans st = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *st_);
    }

    // optional .pb.fasinhTrans ft = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *ft_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .pb.logicleTrans lgt = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lgt_);
    }

    // optional .pb.logGML2Trans lgml2t = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lgml2t_);
    }

    // optional .pb.TRANS_TYPE trans_type = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_type());
    }

    // optional bool isGateOnly = 2;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool isComputed = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 type = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void transformation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const transformation*>(&from));
}

void transformation::MergeFrom(const transformation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.transformation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      channel_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.channel_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_caltbl()->::pb::calibrationTable::MergeFrom(from.caltbl());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_bt()->::pb::biexpTrans::MergeFrom(from.bt());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_lt()->::pb::logTrans::MergeFrom(from.lt());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_flt()->::pb::flinTrans::MergeFrom(from.flt());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_st()->::pb::scaleTrans::MergeFrom(from.st());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_ft()->::pb::fasinhTrans::MergeFrom(from.ft());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_lgt()->::pb::logicleTrans::MergeFrom(from.lgt());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_lgml2t()->::pb::logGML2Trans::MergeFrom(from.lgml2t());
    }
    if (cached_has_bits & 0x00000400u) {
      trans_type_ = from.trans_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      isgateonly_ = from.isgateonly_;
    }
    if (cached_has_bits & 0x00001000u) {
      iscomputed_ = from.iscomputed_;
    }
    if (cached_has_bits & 0x00002000u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void transformation::CopyFrom(const transformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.transformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool transformation::IsInitialized() const {
  return true;
}

void transformation::Swap(transformation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void transformation::InternalSwap(transformation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  channel_.Swap(&other->channel_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(caltbl_, other->caltbl_);
  swap(bt_, other->bt_);
  swap(lt_, other->lt_);
  swap(flt_, other->flt_);
  swap(st_, other->st_);
  swap(ft_, other->ft_);
  swap(lgt_, other->lgt_);
  swap(lgml2t_, other->lgml2t_);
  swap(trans_type_, other->trans_type_);
  swap(isgateonly_, other->isgateonly_);
  swap(iscomputed_, other->iscomputed_);
  swap(type_, other->type_);
}

::std::string transformation::GetTypeName() const {
  return "pb.transformation";
}


// ===================================================================

void trans_pair::InitAsDefaultInstance() {
  ::pb::_trans_pair_default_instance_._instance.get_mutable()->trans_ = const_cast< ::pb::transformation*>(
      ::pb::transformation::internal_default_instance());
}
class trans_pair::HasBitSetters {
 public:
  static void set_has_name(trans_pair* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_trans_address(trans_pair* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::pb::transformation& trans(const trans_pair* msg);
  static void set_has_trans(trans_pair* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::pb::transformation&
trans_pair::HasBitSetters::trans(const trans_pair* msg) {
  return *msg->trans_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int trans_pair::kNameFieldNumber;
const int trans_pair::kTransAddressFieldNumber;
const int trans_pair::kTransFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

trans_pair::trans_pair()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.trans_pair)
}
trans_pair::trans_pair(const trans_pair& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_trans()) {
    trans_ = new ::pb::transformation(*from.trans_);
  } else {
    trans_ = nullptr;
  }
  trans_address_ = from.trans_address_;
  // @@protoc_insertion_point(copy_constructor:pb.trans_pair)
}

void trans_pair::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_trans_pair_GatingSet_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&trans_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&trans_address_) -
      reinterpret_cast<char*>(&trans_)) + sizeof(trans_address_));
}

trans_pair::~trans_pair() {
  // @@protoc_insertion_point(destructor:pb.trans_pair)
  SharedDtor();
}

void trans_pair::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete trans_;
}

void trans_pair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const trans_pair& trans_pair::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_trans_pair_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void trans_pair::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.trans_pair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(trans_ != nullptr);
      trans_->Clear();
    }
  }
  trans_address_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* trans_pair::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<trans_pair*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 trans_address = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_trans_address(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.transformation trans = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::transformation::_InternalParse;
        object = msg->mutable_trans();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool trans_pair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.trans_pair)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 trans_address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_trans_address(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &trans_address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.transformation trans = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_trans()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.trans_pair)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.trans_pair)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void trans_pair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.trans_pair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint64 trans_address = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->trans_address(), output);
  }

  // optional .pb.transformation trans = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, HasBitSetters::trans(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.trans_pair)
}

size_t trans_pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.trans_pair)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .pb.transformation trans = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *trans_);
    }

    // optional uint64 trans_address = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->trans_address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void trans_pair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const trans_pair*>(&from));
}

void trans_pair::MergeFrom(const trans_pair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.trans_pair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_trans()->::pb::transformation::MergeFrom(from.trans());
    }
    if (cached_has_bits & 0x00000004u) {
      trans_address_ = from.trans_address_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void trans_pair::CopyFrom(const trans_pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.trans_pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trans_pair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void trans_pair::Swap(trans_pair* other) {
  if (other == this) return;
  InternalSwap(other);
}
void trans_pair::InternalSwap(trans_pair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(trans_, other->trans_);
  swap(trans_address_, other->trans_address_);
}

::std::string trans_pair::GetTypeName() const {
  return "pb.trans_pair";
}


// ===================================================================

void trans_local::InitAsDefaultInstance() {
}
class trans_local::HasBitSetters {
 public:
  static void set_has_groupname(trans_local* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int trans_local::kTpFieldNumber;
const int trans_local::kGroupNameFieldNumber;
const int trans_local::kSampleIDsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

trans_local::trans_local()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.trans_local)
}
trans_local::trans_local(const trans_local& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      tp_(from.tp_),
      sampleids_(from.sampleids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  groupname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_groupname()) {
    groupname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.groupname_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.trans_local)
}

void trans_local::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_trans_local_GatingSet_2eproto.base);
  groupname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

trans_local::~trans_local() {
  // @@protoc_insertion_point(destructor:pb.trans_local)
  SharedDtor();
}

void trans_local::SharedDtor() {
  groupname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void trans_local::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const trans_local& trans_local::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_trans_local_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void trans_local::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.trans_local)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tp_.Clear();
  sampleids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    groupname_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* trans_local::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<trans_local*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .pb.trans_pair tp = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::trans_pair::_InternalParse;
          object = msg->add_tp();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // optional string groupName = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_groupname();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated uint32 sampleIDs = 3 [packed = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 26) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
          object = msg->mutable_sampleids();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        do {
          msg->add_sampleids(::google::protobuf::internal::ReadVarint(&ptr));
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 24 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool trans_local::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.trans_local)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pb.trans_pair tp = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_tp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string groupName = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_groupname()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 sampleIDs = 3 [packed = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_sampleids())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 26u, input, this->mutable_sampleids())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.trans_local)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.trans_local)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void trans_local::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.trans_local)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.trans_pair tp = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->tp_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->tp(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string groupName = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->groupname(), output);
  }

  // repeated uint32 sampleIDs = 3 [packed = true];
  if (this->sampleids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_sampleids_cached_byte_size_.load(
        std::memory_order_relaxed));
  }
  for (int i = 0, n = this->sampleids_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->sampleids(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.trans_local)
}

size_t trans_local::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.trans_local)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.trans_pair tp = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->tp_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->tp(static_cast<int>(i)));
    }
  }

  // repeated uint32 sampleIDs = 3 [packed = true];
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->sampleids_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _sampleids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional string groupName = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->groupname());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void trans_local::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const trans_local*>(&from));
}

void trans_local::MergeFrom(const trans_local& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.trans_local)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tp_.MergeFrom(from.tp_);
  sampleids_.MergeFrom(from.sampleids_);
  if (from.has_groupname()) {
    _has_bits_[0] |= 0x00000001u;
    groupname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.groupname_);
  }
}

void trans_local::CopyFrom(const trans_local& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.trans_local)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trans_local::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->tp())) return false;
  return true;
}

void trans_local::Swap(trans_local* other) {
  if (other == this) return;
  InternalSwap(other);
}
void trans_local::InternalSwap(trans_local* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&tp_)->InternalSwap(CastToBase(&other->tp_));
  sampleids_.InternalSwap(&other->sampleids_);
  groupname_.Swap(&other->groupname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::std::string trans_local::GetTypeName() const {
  return "pb.trans_local";
}


// ===================================================================

void POPINDICES::InitAsDefaultInstance() {
}
class POPINDICES::HasBitSetters {
 public:
  static void set_has_nevents(POPINDICES* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_indtype(POPINDICES* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_bind(POPINDICES* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int POPINDICES::kNEventsFieldNumber;
const int POPINDICES::kIndtypeFieldNumber;
const int POPINDICES::kIIndFieldNumber;
const int POPINDICES::kBIndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

POPINDICES::POPINDICES()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.POPINDICES)
}
POPINDICES::POPINDICES(const POPINDICES& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      iind_(from.iind_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  bind_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_bind()) {
    bind_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bind_);
  }
  ::memcpy(&nevents_, &from.nevents_,
    static_cast<size_t>(reinterpret_cast<char*>(&indtype_) -
    reinterpret_cast<char*>(&nevents_)) + sizeof(indtype_));
  // @@protoc_insertion_point(copy_constructor:pb.POPINDICES)
}

void POPINDICES::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_POPINDICES_GatingSet_2eproto.base);
  bind_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&nevents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&indtype_) -
      reinterpret_cast<char*>(&nevents_)) + sizeof(indtype_));
}

POPINDICES::~POPINDICES() {
  // @@protoc_insertion_point(destructor:pb.POPINDICES)
  SharedDtor();
}

void POPINDICES::SharedDtor() {
  bind_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void POPINDICES::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const POPINDICES& POPINDICES::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_POPINDICES_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void POPINDICES::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.POPINDICES)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  iind_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    bind_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&nevents_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&indtype_) -
        reinterpret_cast<char*>(&nevents_)) + sizeof(indtype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* POPINDICES::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<POPINDICES*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required uint32 nEvents = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_nevents(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .pb.ind_type indtype = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::pb::ind_type_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_indtype(static_cast<::pb::ind_type>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated uint32 iInd = 3 [packed = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 26) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
          object = msg->mutable_iind();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        do {
          msg->add_iind(::google::protobuf::internal::ReadVarint(&ptr));
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 24 && (ptr += 1));
        break;
      }
      // optional bytes bInd = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_bind();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool POPINDICES::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.POPINDICES)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 nEvents = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_nevents(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nevents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .pb.ind_type indtype = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ind_type_IsValid(value)) {
            set_indtype(static_cast< ::pb::ind_type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 iInd = 3 [packed = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_iind())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 26u, input, this->mutable_iind())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes bInd = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bind()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.POPINDICES)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.POPINDICES)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void POPINDICES::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.POPINDICES)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 nEvents = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nevents(), output);
  }

  // required .pb.ind_type indtype = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->indtype(), output);
  }

  // repeated uint32 iInd = 3 [packed = true];
  if (this->iind_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_iind_cached_byte_size_.load(
        std::memory_order_relaxed));
  }
  for (int i = 0, n = this->iind_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->iind(i), output);
  }

  // optional bytes bInd = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->bind(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.POPINDICES)
}

size_t POPINDICES::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.POPINDICES)
  size_t total_size = 0;

  if (has_nevents()) {
    // required uint32 nEvents = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->nevents());
  }

  if (has_indtype()) {
    // required .pb.ind_type indtype = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->indtype());
  }

  return total_size;
}
size_t POPINDICES::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.POPINDICES)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 nEvents = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->nevents());

    // required .pb.ind_type indtype = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->indtype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 iInd = 3 [packed = true];
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->iind_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _iind_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional bytes bInd = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->bind());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void POPINDICES::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const POPINDICES*>(&from));
}

void POPINDICES::MergeFrom(const POPINDICES& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.POPINDICES)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  iind_.MergeFrom(from.iind_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      bind_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bind_);
    }
    if (cached_has_bits & 0x00000002u) {
      nevents_ = from.nevents_;
    }
    if (cached_has_bits & 0x00000004u) {
      indtype_ = from.indtype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void POPINDICES::CopyFrom(const POPINDICES& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.POPINDICES)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool POPINDICES::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void POPINDICES::Swap(POPINDICES* other) {
  if (other == this) return;
  InternalSwap(other);
}
void POPINDICES::InternalSwap(POPINDICES* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  iind_.InternalSwap(&other->iind_);
  bind_.Swap(&other->bind_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(nevents_, other->nevents_);
  swap(indtype_, other->indtype_);
}

::std::string POPINDICES::GetTypeName() const {
  return "pb.POPINDICES";
}


// ===================================================================

void nodeProperties::InitAsDefaultInstance() {
  ::pb::_nodeProperties_default_instance_._instance.get_mutable()->indices_ = const_cast< ::pb::POPINDICES*>(
      ::pb::POPINDICES::internal_default_instance());
  ::pb::_nodeProperties_default_instance_._instance.get_mutable()->thisgate_ = const_cast< ::pb::gate*>(
      ::pb::gate::internal_default_instance());
}
class nodeProperties::HasBitSetters {
 public:
  static void set_has_thisname(nodeProperties* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_hidden(nodeProperties* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::pb::POPINDICES& indices(const nodeProperties* msg);
  static void set_has_indices(nodeProperties* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::pb::gate& thisgate(const nodeProperties* msg);
  static void set_has_thisgate(nodeProperties* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::pb::POPINDICES&
nodeProperties::HasBitSetters::indices(const nodeProperties* msg) {
  return *msg->indices_;
}
const ::pb::gate&
nodeProperties::HasBitSetters::thisgate(const nodeProperties* msg) {
  return *msg->thisgate_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int nodeProperties::kThisNameFieldNumber;
const int nodeProperties::kFjStatsFieldNumber;
const int nodeProperties::kFcStatsFieldNumber;
const int nodeProperties::kHiddenFieldNumber;
const int nodeProperties::kIndicesFieldNumber;
const int nodeProperties::kThisGateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

nodeProperties::nodeProperties()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.nodeProperties)
}
nodeProperties::nodeProperties(const nodeProperties& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      fjstats_(from.fjstats_),
      fcstats_(from.fcstats_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  thisname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_thisname()) {
    thisname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.thisname_);
  }
  if (from.has_indices()) {
    indices_ = new ::pb::POPINDICES(*from.indices_);
  } else {
    indices_ = nullptr;
  }
  if (from.has_thisgate()) {
    thisgate_ = new ::pb::gate(*from.thisgate_);
  } else {
    thisgate_ = nullptr;
  }
  hidden_ = from.hidden_;
  // @@protoc_insertion_point(copy_constructor:pb.nodeProperties)
}

void nodeProperties::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_nodeProperties_GatingSet_2eproto.base);
  thisname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&indices_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hidden_) -
      reinterpret_cast<char*>(&indices_)) + sizeof(hidden_));
}

nodeProperties::~nodeProperties() {
  // @@protoc_insertion_point(destructor:pb.nodeProperties)
  SharedDtor();
}

void nodeProperties::SharedDtor() {
  thisname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete indices_;
  if (this != internal_default_instance()) delete thisgate_;
}

void nodeProperties::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const nodeProperties& nodeProperties::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_nodeProperties_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void nodeProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.nodeProperties)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fjstats_.Clear();
  fcstats_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      thisname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(indices_ != nullptr);
      indices_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(thisgate_ != nullptr);
      thisgate_->Clear();
    }
  }
  hidden_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* nodeProperties::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<nodeProperties*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string thisName = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_thisname();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated .pb.POPSTATS fjStats = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::POPSTATS::_InternalParse;
          object = msg->add_fjstats();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // repeated .pb.POPSTATS fcStats = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::POPSTATS::_InternalParse;
          object = msg->add_fcstats();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      // required bool hidden = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_hidden(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.POPINDICES indices = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::POPINDICES::_InternalParse;
        object = msg->mutable_indices();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.gate thisGate = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::gate::_InternalParse;
        object = msg->mutable_thisgate();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool nodeProperties::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.nodeProperties)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string thisName = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_thisname()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.POPSTATS fjStats = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_fjstats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.POPSTATS fcStats = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_fcstats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool hidden = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_hidden(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hidden_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.POPINDICES indices = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_indices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.gate thisGate = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_thisgate()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.nodeProperties)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.nodeProperties)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void nodeProperties::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.nodeProperties)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string thisName = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->thisname(), output);
  }

  // repeated .pb.POPSTATS fjStats = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->fjstats_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2,
      this->fjstats(static_cast<int>(i)),
      output);
  }

  // repeated .pb.POPSTATS fcStats = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->fcstats_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3,
      this->fcstats(static_cast<int>(i)),
      output);
  }

  // required bool hidden = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->hidden(), output);
  }

  // optional .pb.POPINDICES indices = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, HasBitSetters::indices(this), output);
  }

  // optional .pb.gate thisGate = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, HasBitSetters::thisgate(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.nodeProperties)
}

size_t nodeProperties::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb.nodeProperties)
  size_t total_size = 0;

  if (has_thisname()) {
    // required string thisName = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->thisname());
  }

  if (has_hidden()) {
    // required bool hidden = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t nodeProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.nodeProperties)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required string thisName = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->thisname());

    // required bool hidden = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.POPSTATS fjStats = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->fjstats_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->fjstats(static_cast<int>(i)));
    }
  }

  // repeated .pb.POPSTATS fcStats = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->fcstats_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->fcstats(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .pb.POPINDICES indices = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *indices_);
    }

    // optional .pb.gate thisGate = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *thisgate_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void nodeProperties::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const nodeProperties*>(&from));
}

void nodeProperties::MergeFrom(const nodeProperties& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.nodeProperties)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fjstats_.MergeFrom(from.fjstats_);
  fcstats_.MergeFrom(from.fcstats_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      thisname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.thisname_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_indices()->::pb::POPINDICES::MergeFrom(from.indices());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_thisgate()->::pb::gate::MergeFrom(from.thisgate());
    }
    if (cached_has_bits & 0x00000008u) {
      hidden_ = from.hidden_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void nodeProperties::CopyFrom(const nodeProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.nodeProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool nodeProperties::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->fjstats())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->fcstats())) return false;
  if (has_indices()) {
    if (!this->indices_->IsInitialized()) return false;
  }
  if (has_thisgate()) {
    if (!this->thisgate_->IsInitialized()) return false;
  }
  return true;
}

void nodeProperties::Swap(nodeProperties* other) {
  if (other == this) return;
  InternalSwap(other);
}
void nodeProperties::InternalSwap(nodeProperties* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&fjstats_)->InternalSwap(CastToBase(&other->fjstats_));
  CastToBase(&fcstats_)->InternalSwap(CastToBase(&other->fcstats_));
  thisname_.Swap(&other->thisname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(indices_, other->indices_);
  swap(thisgate_, other->thisgate_);
  swap(hidden_, other->hidden_);
}

::std::string nodeProperties::GetTypeName() const {
  return "pb.nodeProperties";
}


// ===================================================================

void treeNodes::InitAsDefaultInstance() {
  ::pb::_treeNodes_default_instance_._instance.get_mutable()->node_ = const_cast< ::pb::nodeProperties*>(
      ::pb::nodeProperties::internal_default_instance());
}
class treeNodes::HasBitSetters {
 public:
  static const ::pb::nodeProperties& node(const treeNodes* msg);
  static void set_has_node(treeNodes* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_parent(treeNodes* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::pb::nodeProperties&
treeNodes::HasBitSetters::node(const treeNodes* msg) {
  return *msg->node_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int treeNodes::kNodeFieldNumber;
const int treeNodes::kParentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

treeNodes::treeNodes()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.treeNodes)
}
treeNodes::treeNodes(const treeNodes& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_node()) {
    node_ = new ::pb::nodeProperties(*from.node_);
  } else {
    node_ = nullptr;
  }
  parent_ = from.parent_;
  // @@protoc_insertion_point(copy_constructor:pb.treeNodes)
}

void treeNodes::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_treeNodes_GatingSet_2eproto.base);
  ::memset(&node_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&parent_) -
      reinterpret_cast<char*>(&node_)) + sizeof(parent_));
}

treeNodes::~treeNodes() {
  // @@protoc_insertion_point(destructor:pb.treeNodes)
  SharedDtor();
}

void treeNodes::SharedDtor() {
  if (this != internal_default_instance()) delete node_;
}

void treeNodes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const treeNodes& treeNodes::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_treeNodes_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void treeNodes::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.treeNodes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(node_ != nullptr);
    node_->Clear();
  }
  parent_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* treeNodes::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<treeNodes*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .pb.nodeProperties node = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::nodeProperties::_InternalParse;
        object = msg->mutable_node();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 parent = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_parent(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool treeNodes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.treeNodes)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .pb.nodeProperties node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 parent = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_parent(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &parent_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.treeNodes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.treeNodes)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void treeNodes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.treeNodes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pb.nodeProperties node = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, HasBitSetters::node(this), output);
  }

  // optional uint32 parent = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->parent(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.treeNodes)
}

size_t treeNodes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.treeNodes)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .pb.nodeProperties node = 1;
  if (has_node()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *node_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 parent = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->parent());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void treeNodes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const treeNodes*>(&from));
}

void treeNodes::MergeFrom(const treeNodes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.treeNodes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_node()->::pb::nodeProperties::MergeFrom(from.node());
    }
    if (cached_has_bits & 0x00000002u) {
      parent_ = from.parent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void treeNodes::CopyFrom(const treeNodes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.treeNodes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool treeNodes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void treeNodes::Swap(treeNodes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void treeNodes::InternalSwap(treeNodes* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(node_, other->node_);
  swap(parent_, other->parent_);
}

::std::string treeNodes::GetTypeName() const {
  return "pb.treeNodes";
}


// ===================================================================

void populationTree::InitAsDefaultInstance() {
}
class populationTree::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int populationTree::kNodeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

populationTree::populationTree()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.populationTree)
}
populationTree::populationTree(const populationTree& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      node_(from.node_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.populationTree)
}

void populationTree::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_populationTree_GatingSet_2eproto.base);
}

populationTree::~populationTree() {
  // @@protoc_insertion_point(destructor:pb.populationTree)
  SharedDtor();
}

void populationTree::SharedDtor() {
}

void populationTree::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const populationTree& populationTree::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_populationTree_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void populationTree::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.populationTree)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  node_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* populationTree::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<populationTree*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .pb.treeNodes node = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::treeNodes::_InternalParse;
          object = msg->add_node();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool populationTree::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.populationTree)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pb.treeNodes node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.populationTree)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.populationTree)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void populationTree::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.populationTree)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.treeNodes node = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->node_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->node(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.populationTree)
}

size_t populationTree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.populationTree)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.treeNodes node = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->node_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->node(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void populationTree::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const populationTree*>(&from));
}

void populationTree::MergeFrom(const populationTree& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.populationTree)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  node_.MergeFrom(from.node_);
}

void populationTree::CopyFrom(const populationTree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.populationTree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool populationTree::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->node())) return false;
  return true;
}

void populationTree::Swap(populationTree* other) {
  if (other == this) return;
  InternalSwap(other);
}
void populationTree::InternalSwap(populationTree* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&node_)->InternalSwap(CastToBase(&other->node_));
}

::std::string populationTree::GetTypeName() const {
  return "pb.populationTree";
}


// ===================================================================

void COMP::InitAsDefaultInstance() {
}
class COMP::HasBitSetters {
 public:
  static void set_has_cid(COMP* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_prefix(COMP* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_suffix(COMP* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_name(COMP* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_comment(COMP* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int COMP::kCidFieldNumber;
const int COMP::kPrefixFieldNumber;
const int COMP::kSuffixFieldNumber;
const int COMP::kNameFieldNumber;
const int COMP::kCommentFieldNumber;
const int COMP::kMarkerFieldNumber;
const int COMP::kSpillOverFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

COMP::COMP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.COMP)
}
COMP::COMP(const COMP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      marker_(from.marker_),
      spillover_(from.spillover_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_cid()) {
    cid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cid_);
  }
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_prefix()) {
    prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
  }
  suffix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_suffix()) {
    suffix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.suffix_);
  }
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_comment()) {
    comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.COMP)
}

void COMP::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_COMP_GatingSet_2eproto.base);
  cid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  suffix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

COMP::~COMP() {
  // @@protoc_insertion_point(destructor:pb.COMP)
  SharedDtor();
}

void COMP::SharedDtor() {
  cid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  comment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void COMP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const COMP& COMP::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_COMP_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void COMP::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.COMP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  marker_.Clear();
  spillover_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      cid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      prefix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      suffix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      comment_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* COMP::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<COMP*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string cid = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_cid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string prefix = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_prefix();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string suffix = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_suffix();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string name = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string comment = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_comment();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated string marker = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_marker();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 50 && (ptr += 1));
        break;
      }
      // repeated float spillOver = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 61) {
          do {
            msg->add_spillover(::google::protobuf::io::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 61 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFloatParser;
        object = msg->mutable_spillover();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool COMP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.COMP)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string cid = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string prefix = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_prefix()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string suffix = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_suffix()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string comment = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string marker = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_marker()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float spillOver = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 61u, input, this->mutable_spillover())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_spillover())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.COMP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.COMP)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void COMP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.COMP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->cid(), output);
  }

  // optional string prefix = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->prefix(), output);
  }

  // optional string suffix = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->suffix(), output);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->name(), output);
  }

  // optional string comment = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->comment(), output);
  }

  // repeated string marker = 6;
  for (int i = 0, n = this->marker_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->marker(i), output);
  }

  // repeated float spillOver = 7;
  for (int i = 0, n = this->spillover_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      7, this->spillover(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.COMP)
}

size_t COMP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.COMP)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string marker = 6;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->marker_size());
  for (int i = 0, n = this->marker_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->marker(i));
  }

  // repeated float spillOver = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->spillover_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->spillover_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string cid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cid());
    }

    // optional string prefix = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->prefix());
    }

    // optional string suffix = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->suffix());
    }

    // optional string name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string comment = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void COMP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const COMP*>(&from));
}

void COMP::MergeFrom(const COMP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.COMP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  marker_.MergeFrom(from.marker_);
  spillover_.MergeFrom(from.spillover_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      cid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cid_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      suffix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.suffix_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      comment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.comment_);
    }
  }
}

void COMP::CopyFrom(const COMP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.COMP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool COMP::IsInitialized() const {
  return true;
}

void COMP::Swap(COMP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void COMP::InternalSwap(COMP* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  marker_.InternalSwap(CastToBase(&other->marker_));
  spillover_.InternalSwap(&other->spillover_);
  cid_.Swap(&other->cid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  prefix_.Swap(&other->prefix_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  suffix_.Swap(&other->suffix_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  comment_.Swap(&other->comment_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::std::string COMP::GetTypeName() const {
  return "pb.COMP";
}


// ===================================================================

void PARAM::InitAsDefaultInstance() {
}
class PARAM::HasBitSetters {
 public:
  static void set_has_param(PARAM* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_log(PARAM* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_range(PARAM* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_highvalue(PARAM* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_calibrationindex(PARAM* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PARAM::kParamFieldNumber;
const int PARAM::kLogFieldNumber;
const int PARAM::kRangeFieldNumber;
const int PARAM::kHighValueFieldNumber;
const int PARAM::kCalibrationIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PARAM::PARAM()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.PARAM)
}
PARAM::PARAM(const PARAM& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  param_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_param()) {
    param_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.param_);
  }
  ::memcpy(&log_, &from.log_,
    static_cast<size_t>(reinterpret_cast<char*>(&calibrationindex_) -
    reinterpret_cast<char*>(&log_)) + sizeof(calibrationindex_));
  // @@protoc_insertion_point(copy_constructor:pb.PARAM)
}

void PARAM::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PARAM_GatingSet_2eproto.base);
  param_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&log_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&calibrationindex_) -
      reinterpret_cast<char*>(&log_)) + sizeof(calibrationindex_));
}

PARAM::~PARAM() {
  // @@protoc_insertion_point(destructor:pb.PARAM)
  SharedDtor();
}

void PARAM::SharedDtor() {
  param_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PARAM::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PARAM& PARAM::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PARAM_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void PARAM::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.PARAM)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    param_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&log_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&calibrationindex_) -
        reinterpret_cast<char*>(&log_)) + sizeof(calibrationindex_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PARAM::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PARAM*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string param = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_param();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bool log = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_log(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 range = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_range(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 highValue = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_highvalue(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 calibrationIndex = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_calibrationindex(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PARAM::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.PARAM)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string param = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_param()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool log = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_log(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &log_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 range = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_range(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &range_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 highValue = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_highvalue(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &highvalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 calibrationIndex = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_calibrationindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &calibrationindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.PARAM)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.PARAM)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PARAM::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.PARAM)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string param = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->param(), output);
  }

  // optional bool log = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->log(), output);
  }

  // optional uint32 range = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->range(), output);
  }

  // optional uint32 highValue = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->highvalue(), output);
  }

  // optional uint32 calibrationIndex = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->calibrationindex(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.PARAM)
}

size_t PARAM::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.PARAM)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string param = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->param());
    }

    // optional bool log = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 range = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->range());
    }

    // optional uint32 highValue = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->highvalue());
    }

    // optional uint32 calibrationIndex = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->calibrationindex());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PARAM::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PARAM*>(&from));
}

void PARAM::MergeFrom(const PARAM& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.PARAM)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      param_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.param_);
    }
    if (cached_has_bits & 0x00000002u) {
      log_ = from.log_;
    }
    if (cached_has_bits & 0x00000004u) {
      range_ = from.range_;
    }
    if (cached_has_bits & 0x00000008u) {
      highvalue_ = from.highvalue_;
    }
    if (cached_has_bits & 0x00000010u) {
      calibrationindex_ = from.calibrationindex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PARAM::CopyFrom(const PARAM& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.PARAM)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PARAM::IsInitialized() const {
  return true;
}

void PARAM::Swap(PARAM* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PARAM::InternalSwap(PARAM* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  param_.Swap(&other->param_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(log_, other->log_);
  swap(range_, other->range_);
  swap(highvalue_, other->highvalue_);
  swap(calibrationindex_, other->calibrationindex_);
}

::std::string PARAM::GetTypeName() const {
  return "pb.PARAM";
}


// ===================================================================

void GatingHierarchy::InitAsDefaultInstance() {
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->tree_ = const_cast< ::pb::populationTree*>(
      ::pb::populationTree::internal_default_instance());
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->comp_ = const_cast< ::pb::COMP*>(
      ::pb::COMP::internal_default_instance());
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->trans_ = const_cast< ::pb::trans_local*>(
      ::pb::trans_local::internal_default_instance());
  ::pb::_GatingHierarchy_default_instance_._instance.get_mutable()->frame_ = const_cast< ::pb::CytoFrame*>(
      ::pb::CytoFrame::internal_default_instance());
}
class GatingHierarchy::HasBitSetters {
 public:
  static const ::pb::populationTree& tree(const GatingHierarchy* msg);
  static void set_has_tree(GatingHierarchy* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::pb::COMP& comp(const GatingHierarchy* msg);
  static void set_has_comp(GatingHierarchy* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_isloaded(GatingHierarchy* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::pb::trans_local& trans(const GatingHierarchy* msg);
  static void set_has_trans(GatingHierarchy* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::pb::CytoFrame& frame(const GatingHierarchy* msg);
  static void set_has_frame(GatingHierarchy* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::pb::populationTree&
GatingHierarchy::HasBitSetters::tree(const GatingHierarchy* msg) {
  return *msg->tree_;
}
const ::pb::COMP&
GatingHierarchy::HasBitSetters::comp(const GatingHierarchy* msg) {
  return *msg->comp_;
}
const ::pb::trans_local&
GatingHierarchy::HasBitSetters::trans(const GatingHierarchy* msg) {
  return *msg->trans_;
}
const ::pb::CytoFrame&
GatingHierarchy::HasBitSetters::frame(const GatingHierarchy* msg) {
  return *msg->frame_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GatingHierarchy::kTreeFieldNumber;
const int GatingHierarchy::kCompFieldNumber;
const int GatingHierarchy::kIsLoadedFieldNumber;
const int GatingHierarchy::kTransFlagFieldNumber;
const int GatingHierarchy::kTransFieldNumber;
const int GatingHierarchy::kFrameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GatingHierarchy::GatingHierarchy()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.GatingHierarchy)
}
GatingHierarchy::GatingHierarchy(const GatingHierarchy& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      transflag_(from.transflag_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_comp()) {
    comp_ = new ::pb::COMP(*from.comp_);
  } else {
    comp_ = nullptr;
  }
  if (from.has_tree()) {
    tree_ = new ::pb::populationTree(*from.tree_);
  } else {
    tree_ = nullptr;
  }
  if (from.has_trans()) {
    trans_ = new ::pb::trans_local(*from.trans_);
  } else {
    trans_ = nullptr;
  }
  if (from.has_frame()) {
    frame_ = new ::pb::CytoFrame(*from.frame_);
  } else {
    frame_ = nullptr;
  }
  isloaded_ = from.isloaded_;
  // @@protoc_insertion_point(copy_constructor:pb.GatingHierarchy)
}

void GatingHierarchy::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GatingHierarchy_GatingSet_2eproto.base);
  ::memset(&comp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isloaded_) -
      reinterpret_cast<char*>(&comp_)) + sizeof(isloaded_));
}

GatingHierarchy::~GatingHierarchy() {
  // @@protoc_insertion_point(destructor:pb.GatingHierarchy)
  SharedDtor();
}

void GatingHierarchy::SharedDtor() {
  if (this != internal_default_instance()) delete comp_;
  if (this != internal_default_instance()) delete tree_;
  if (this != internal_default_instance()) delete trans_;
  if (this != internal_default_instance()) delete frame_;
}

void GatingHierarchy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GatingHierarchy& GatingHierarchy::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GatingHierarchy_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void GatingHierarchy::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GatingHierarchy)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transflag_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(comp_ != nullptr);
      comp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(tree_ != nullptr);
      tree_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(trans_ != nullptr);
      trans_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(frame_ != nullptr);
      frame_->Clear();
    }
  }
  isloaded_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GatingHierarchy::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GatingHierarchy*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .pb.COMP comp = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::COMP::_InternalParse;
        object = msg->mutable_comp();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // required .pb.populationTree tree = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::populationTree::_InternalParse;
        object = msg->mutable_tree();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool isLoaded = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_isloaded(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .pb.PARAM transFlag = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::PARAM::_InternalParse;
          object = msg->add_transflag();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 34 && (ptr += 1));
        break;
      }
      // optional .pb.trans_local trans = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::trans_local::_InternalParse;
        object = msg->mutable_trans();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .pb.CytoFrame frame = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::CytoFrame::_InternalParse;
        object = msg->mutable_frame();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GatingHierarchy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.GatingHierarchy)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pb.COMP comp = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_comp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .pb.populationTree tree = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_tree()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool isLoaded = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_isloaded(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isloaded_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.PARAM transFlag = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_transflag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.trans_local trans = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_trans()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.CytoFrame frame = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_frame()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.GatingHierarchy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.GatingHierarchy)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GatingHierarchy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.GatingHierarchy)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pb.COMP comp = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, HasBitSetters::comp(this), output);
  }

  // required .pb.populationTree tree = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, HasBitSetters::tree(this), output);
  }

  // optional bool isLoaded = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isloaded(), output);
  }

  // repeated .pb.PARAM transFlag = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->transflag_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4,
      this->transflag(static_cast<int>(i)),
      output);
  }

  // optional .pb.trans_local trans = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, HasBitSetters::trans(this), output);
  }

  // optional .pb.CytoFrame frame = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, HasBitSetters::frame(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.GatingHierarchy)
}

size_t GatingHierarchy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GatingHierarchy)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .pb.populationTree tree = 2;
  if (has_tree()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *tree_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.PARAM transFlag = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->transflag_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->transflag(static_cast<int>(i)));
    }
  }

  // optional .pb.COMP comp = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *comp_);
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional .pb.trans_local trans = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *trans_);
    }

    // optional .pb.CytoFrame frame = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *frame_);
    }

    // optional bool isLoaded = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatingHierarchy::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GatingHierarchy*>(&from));
}

void GatingHierarchy::MergeFrom(const GatingHierarchy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.GatingHierarchy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  transflag_.MergeFrom(from.transflag_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_comp()->::pb::COMP::MergeFrom(from.comp());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_tree()->::pb::populationTree::MergeFrom(from.tree());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_trans()->::pb::trans_local::MergeFrom(from.trans());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_frame()->::pb::CytoFrame::MergeFrom(from.frame());
    }
    if (cached_has_bits & 0x00000010u) {
      isloaded_ = from.isloaded_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GatingHierarchy::CopyFrom(const GatingHierarchy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GatingHierarchy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatingHierarchy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_tree()) {
    if (!this->tree_->IsInitialized()) return false;
  }
  if (has_trans()) {
    if (!this->trans_->IsInitialized()) return false;
  }
  if (has_frame()) {
    if (!this->frame_->IsInitialized()) return false;
  }
  return true;
}

void GatingHierarchy::Swap(GatingHierarchy* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GatingHierarchy::InternalSwap(GatingHierarchy* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&transflag_)->InternalSwap(CastToBase(&other->transflag_));
  swap(comp_, other->comp_);
  swap(tree_, other->tree_);
  swap(trans_, other->trans_);
  swap(frame_, other->frame_);
  swap(isloaded_, other->isloaded_);
}

::std::string GatingHierarchy::GetTypeName() const {
  return "pb.GatingHierarchy";
}


// ===================================================================

void CytoFrame::InitAsDefaultInstance() {
}
class CytoFrame::HasBitSetters {
 public:
  static void set_has_is_h5(CytoFrame* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CytoFrame::kIsH5FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CytoFrame::CytoFrame()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.CytoFrame)
}
CytoFrame::CytoFrame(const CytoFrame& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  is_h5_ = from.is_h5_;
  // @@protoc_insertion_point(copy_constructor:pb.CytoFrame)
}

void CytoFrame::SharedCtor() {
  is_h5_ = false;
}

CytoFrame::~CytoFrame() {
  // @@protoc_insertion_point(destructor:pb.CytoFrame)
  SharedDtor();
}

void CytoFrame::SharedDtor() {
}

void CytoFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CytoFrame& CytoFrame::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CytoFrame_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void CytoFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.CytoFrame)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  is_h5_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CytoFrame::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CytoFrame*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required bool is_h5 = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_is_h5(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CytoFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.CytoFrame)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_h5 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_is_h5(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_h5_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.CytoFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.CytoFrame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CytoFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.CytoFrame)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool is_h5 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_h5(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.CytoFrame)
}

size_t CytoFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.CytoFrame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required bool is_h5 = 1;
  if (has_is_h5()) {
    total_size += 1 + 1;
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CytoFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CytoFrame*>(&from));
}

void CytoFrame::MergeFrom(const CytoFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.CytoFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_is_h5()) {
    set_is_h5(from.is_h5());
  }
}

void CytoFrame::CopyFrom(const CytoFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.CytoFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CytoFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void CytoFrame::Swap(CytoFrame* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CytoFrame::InternalSwap(CytoFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(is_h5_, other->is_h5_);
}

::std::string CytoFrame::GetTypeName() const {
  return "pb.CytoFrame";
}


// ===================================================================

void TRANS_TBL::InitAsDefaultInstance() {
  ::pb::_TRANS_TBL_default_instance_._instance.get_mutable()->trans_ = const_cast< ::pb::transformation*>(
      ::pb::transformation::internal_default_instance());
}
class TRANS_TBL::HasBitSetters {
 public:
  static void set_has_trans_address(TRANS_TBL* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::pb::transformation& trans(const TRANS_TBL* msg);
  static void set_has_trans(TRANS_TBL* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::pb::transformation&
TRANS_TBL::HasBitSetters::trans(const TRANS_TBL* msg) {
  return *msg->trans_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TRANS_TBL::kTransAddressFieldNumber;
const int TRANS_TBL::kTransFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TRANS_TBL::TRANS_TBL()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.TRANS_TBL)
}
TRANS_TBL::TRANS_TBL(const TRANS_TBL& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_trans()) {
    trans_ = new ::pb::transformation(*from.trans_);
  } else {
    trans_ = nullptr;
  }
  trans_address_ = from.trans_address_;
  // @@protoc_insertion_point(copy_constructor:pb.TRANS_TBL)
}

void TRANS_TBL::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TRANS_TBL_GatingSet_2eproto.base);
  ::memset(&trans_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&trans_address_) -
      reinterpret_cast<char*>(&trans_)) + sizeof(trans_address_));
}

TRANS_TBL::~TRANS_TBL() {
  // @@protoc_insertion_point(destructor:pb.TRANS_TBL)
  SharedDtor();
}

void TRANS_TBL::SharedDtor() {
  if (this != internal_default_instance()) delete trans_;
}

void TRANS_TBL::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TRANS_TBL& TRANS_TBL::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TRANS_TBL_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void TRANS_TBL::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.TRANS_TBL)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(trans_ != nullptr);
    trans_->Clear();
  }
  trans_address_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TRANS_TBL::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TRANS_TBL*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 trans_address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_trans_address(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .pb.transformation trans = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::pb::transformation::_InternalParse;
        object = msg->mutable_trans();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TRANS_TBL::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.TRANS_TBL)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 trans_address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_trans_address(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &trans_address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .pb.transformation trans = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_trans()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.TRANS_TBL)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.TRANS_TBL)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TRANS_TBL::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.TRANS_TBL)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 trans_address = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->trans_address(), output);
  }

  // optional .pb.transformation trans = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, HasBitSetters::trans(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.TRANS_TBL)
}

size_t TRANS_TBL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.TRANS_TBL)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pb.transformation trans = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *trans_);
    }

    // optional uint64 trans_address = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->trans_address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TRANS_TBL::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TRANS_TBL*>(&from));
}

void TRANS_TBL::MergeFrom(const TRANS_TBL& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.TRANS_TBL)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_trans()->::pb::transformation::MergeFrom(from.trans());
    }
    if (cached_has_bits & 0x00000002u) {
      trans_address_ = from.trans_address_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TRANS_TBL::CopyFrom(const TRANS_TBL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.TRANS_TBL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRANS_TBL::IsInitialized() const {
  return true;
}

void TRANS_TBL::Swap(TRANS_TBL* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TRANS_TBL::InternalSwap(TRANS_TBL* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(trans_, other->trans_);
  swap(trans_address_, other->trans_address_);
}

::std::string TRANS_TBL::GetTypeName() const {
  return "pb.TRANS_TBL";
}


// ===================================================================

void GatingSet::InitAsDefaultInstance() {
}
class GatingSet::HasBitSetters {
 public:
  static void set_has_globalbiexptrans(GatingSet* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_globallintrans(GatingSet* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_guid(GatingSet* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GatingSet::kTransTblFieldNumber;
const int GatingSet::kSampleNameFieldNumber;
const int GatingSet::kGlobalBiExpTransFieldNumber;
const int GatingSet::kGlobalLinTransFieldNumber;
const int GatingSet::kGTransFieldNumber;
const int GatingSet::kGuidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GatingSet::GatingSet()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.GatingSet)
}
GatingSet::GatingSet(const GatingSet& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      samplename_(from.samplename_),
      trans_tbl_(from.trans_tbl_),
      gtrans_(from.gtrans_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_guid()) {
    guid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.guid_);
  }
  ::memcpy(&globalbiexptrans_, &from.globalbiexptrans_,
    static_cast<size_t>(reinterpret_cast<char*>(&globallintrans_) -
    reinterpret_cast<char*>(&globalbiexptrans_)) + sizeof(globallintrans_));
  // @@protoc_insertion_point(copy_constructor:pb.GatingSet)
}

void GatingSet::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GatingSet_GatingSet_2eproto.base);
  guid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&globalbiexptrans_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&globallintrans_) -
      reinterpret_cast<char*>(&globalbiexptrans_)) + sizeof(globallintrans_));
}

GatingSet::~GatingSet() {
  // @@protoc_insertion_point(destructor:pb.GatingSet)
  SharedDtor();
}

void GatingSet::SharedDtor() {
  guid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GatingSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GatingSet& GatingSet::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GatingSet_GatingSet_2eproto.base);
  return *internal_default_instance();
}


void GatingSet::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GatingSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  samplename_.Clear();
  trans_tbl_.Clear();
  gtrans_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    guid_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&globalbiexptrans_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&globallintrans_) -
        reinterpret_cast<char*>(&globalbiexptrans_)) + sizeof(globallintrans_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GatingSet::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GatingSet*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated string sampleName = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_samplename();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // repeated .pb.TRANS_TBL trans_tbl = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::TRANS_TBL::_InternalParse;
          object = msg->add_trans_tbl();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional uint64 globalBiExpTrans = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_globalbiexptrans(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 globalLinTrans = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_globallintrans(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .pb.trans_local gTrans = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::pb::trans_local::_InternalParse;
          object = msg->add_gtrans();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      // optional string guid = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_guid();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GatingSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:pb.GatingSet)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string sampleName = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_samplename()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.TRANS_TBL trans_tbl = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_trans_tbl()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 globalBiExpTrans = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_globalbiexptrans(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &globalbiexptrans_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 globalLinTrans = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_globallintrans(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &globallintrans_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .pb.trans_local gTrans = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_gtrans()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string guid = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.GatingSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.GatingSet)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GatingSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.GatingSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string sampleName = 1;
  for (int i = 0, n = this->samplename_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->samplename(i), output);
  }

  // repeated .pb.TRANS_TBL trans_tbl = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->trans_tbl_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2,
      this->trans_tbl(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 globalBiExpTrans = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->globalbiexptrans(), output);
  }

  // optional uint64 globalLinTrans = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->globallintrans(), output);
  }

  // repeated .pb.trans_local gTrans = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->gtrans_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5,
      this->gtrans(static_cast<int>(i)),
      output);
  }

  // optional string guid = 6;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->guid(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:pb.GatingSet)
}

size_t GatingSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GatingSet)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string sampleName = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->samplename_size());
  for (int i = 0, n = this->samplename_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->samplename(i));
  }

  // repeated .pb.TRANS_TBL trans_tbl = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->trans_tbl_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->trans_tbl(static_cast<int>(i)));
    }
  }

  // repeated .pb.trans_local gTrans = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->gtrans_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->gtrans(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string guid = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }

    // optional uint64 globalBiExpTrans = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->globalbiexptrans());
    }

    // optional uint64 globalLinTrans = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->globallintrans());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatingSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GatingSet*>(&from));
}

void GatingSet::MergeFrom(const GatingSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.GatingSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  samplename_.MergeFrom(from.samplename_);
  trans_tbl_.MergeFrom(from.trans_tbl_);
  gtrans_.MergeFrom(from.gtrans_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      guid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.guid_);
    }
    if (cached_has_bits & 0x00000002u) {
      globalbiexptrans_ = from.globalbiexptrans_;
    }
    if (cached_has_bits & 0x00000004u) {
      globallintrans_ = from.globallintrans_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GatingSet::CopyFrom(const GatingSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GatingSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatingSet::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->gtrans())) return false;
  return true;
}

void GatingSet::Swap(GatingSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GatingSet::InternalSwap(GatingSet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  samplename_.InternalSwap(CastToBase(&other->samplename_));
  CastToBase(&trans_tbl_)->InternalSwap(CastToBase(&other->trans_tbl_));
  CastToBase(&gtrans_)->InternalSwap(CastToBase(&other->gtrans_));
  guid_.Swap(&other->guid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(globalbiexptrans_, other->globalbiexptrans_);
  swap(globallintrans_, other->globallintrans_);
}

::std::string GatingSet::GetTypeName() const {
  return "pb.GatingSet";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::pb::paramRange* Arena::CreateMaybeMessage< ::pb::paramRange >(Arena* arena) {
  return Arena::CreateInternal< ::pb::paramRange >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::rangeGate* Arena::CreateMaybeMessage< ::pb::rangeGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::rangeGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::paramPoly* Arena::CreateMaybeMessage< ::pb::paramPoly >(Arena* arena) {
  return Arena::CreateInternal< ::pb::paramPoly >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::polygonGate* Arena::CreateMaybeMessage< ::pb::polygonGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::polygonGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::coordinate* Arena::CreateMaybeMessage< ::pb::coordinate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::coordinate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::ellipseGate* Arena::CreateMaybeMessage< ::pb::ellipseGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::ellipseGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::BOOL_GATE_OP* Arena::CreateMaybeMessage< ::pb::BOOL_GATE_OP >(Arena* arena) {
  return Arena::CreateInternal< ::pb::BOOL_GATE_OP >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::boolGate* Arena::CreateMaybeMessage< ::pb::boolGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::boolGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::clusterGate* Arena::CreateMaybeMessage< ::pb::clusterGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::clusterGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::quadGate* Arena::CreateMaybeMessage< ::pb::quadGate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::quadGate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::gate* Arena::CreateMaybeMessage< ::pb::gate >(Arena* arena) {
  return Arena::CreateInternal< ::pb::gate >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::POPSTATS* Arena::CreateMaybeMessage< ::pb::POPSTATS >(Arena* arena) {
  return Arena::CreateInternal< ::pb::POPSTATS >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::calibrationTable* Arena::CreateMaybeMessage< ::pb::calibrationTable >(Arena* arena) {
  return Arena::CreateInternal< ::pb::calibrationTable >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::biexpTrans* Arena::CreateMaybeMessage< ::pb::biexpTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::biexpTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::fasinhTrans* Arena::CreateMaybeMessage< ::pb::fasinhTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::fasinhTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::scaleTrans* Arena::CreateMaybeMessage< ::pb::scaleTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::scaleTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::flinTrans* Arena::CreateMaybeMessage< ::pb::flinTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::flinTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::logTrans* Arena::CreateMaybeMessage< ::pb::logTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::logTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::logGML2Trans* Arena::CreateMaybeMessage< ::pb::logGML2Trans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::logGML2Trans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::logicleTrans* Arena::CreateMaybeMessage< ::pb::logicleTrans >(Arena* arena) {
  return Arena::CreateInternal< ::pb::logicleTrans >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::transformation* Arena::CreateMaybeMessage< ::pb::transformation >(Arena* arena) {
  return Arena::CreateInternal< ::pb::transformation >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::trans_pair* Arena::CreateMaybeMessage< ::pb::trans_pair >(Arena* arena) {
  return Arena::CreateInternal< ::pb::trans_pair >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::trans_local* Arena::CreateMaybeMessage< ::pb::trans_local >(Arena* arena) {
  return Arena::CreateInternal< ::pb::trans_local >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::POPINDICES* Arena::CreateMaybeMessage< ::pb::POPINDICES >(Arena* arena) {
  return Arena::CreateInternal< ::pb::POPINDICES >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::nodeProperties* Arena::CreateMaybeMessage< ::pb::nodeProperties >(Arena* arena) {
  return Arena::CreateInternal< ::pb::nodeProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::treeNodes* Arena::CreateMaybeMessage< ::pb::treeNodes >(Arena* arena) {
  return Arena::CreateInternal< ::pb::treeNodes >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::populationTree* Arena::CreateMaybeMessage< ::pb::populationTree >(Arena* arena) {
  return Arena::CreateInternal< ::pb::populationTree >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::COMP* Arena::CreateMaybeMessage< ::pb::COMP >(Arena* arena) {
  return Arena::CreateInternal< ::pb::COMP >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::PARAM* Arena::CreateMaybeMessage< ::pb::PARAM >(Arena* arena) {
  return Arena::CreateInternal< ::pb::PARAM >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GatingHierarchy* Arena::CreateMaybeMessage< ::pb::GatingHierarchy >(Arena* arena) {
  return Arena::CreateInternal< ::pb::GatingHierarchy >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::CytoFrame* Arena::CreateMaybeMessage< ::pb::CytoFrame >(Arena* arena) {
  return Arena::CreateInternal< ::pb::CytoFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::TRANS_TBL* Arena::CreateMaybeMessage< ::pb::TRANS_TBL >(Arena* arena) {
  return Arena::CreateInternal< ::pb::TRANS_TBL >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GatingSet* Arena::CreateMaybeMessage< ::pb::GatingSet >(Arena* arena) {
  return Arena::CreateInternal< ::pb::GatingSet >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
